<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0084)http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html -->
<HTML><HEAD><TITLE>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 5)</TITLE><!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META http-equiv=pragma content=no-cache>
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#000000 link=#008000 bgColor=#ffffff topMargin=10 
stylesrc="../toc.html">
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="100%" colSpan=3>
      <P align=right><A name=top></A><FONT face=Arial size=1>The Art 
      of<BR></FONT><FONT face="Arial Black" size=1>ASSEMBLY LANGUAGE 
      PROGRAMMING</FONT></P></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1><A name=HEADING5></A></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 5)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html">Chapter 
      Thirteen</A> (Part 4)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html">Chapter 
      Thirteen</A> (Part 6)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 5)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD noWrap width="100%" bgColor=#ffffff colSpan=2 height=10><A 
      name=HEADING5-1></A></TD></TR>
  <TR>
    <TD width="100%" bgColor=#f0f0f0 colSpan=2><FONT face=Arial 
      size=4><STRONG>CHAPTER THIRTEEN:<BR>MS-DOS, PC-BIOS AND FILE I/O (Part 
      5)</STRONG></FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 height=10></TD></TR>
  <TR>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-1"><B>13.3.6 
      </B>- MS-DOS Memory Management Functions</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-10"><B>13.3.6.1 
      </B>- Allocate Memory</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-21"><B>13.3.6.2 
      </B>- Deallocate Memory</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-27"><B>13.3.6.3 
      </B>- Modify Memory Allocation</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-36"><B>13.3.6.4 
      </B>- Advanced Memory Management Functions</A> </FONT></TD>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-41"><B>13.3.7 
      </B>- MS-DOS Process Control Functions</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-43"><B>13.3.7.1 
      </B>- Terminate Program Execution</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-50"><B>13.3.7.2 
      </B>- Terminate, but Stay Resident</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#HEADING5-61"><B>13.3.7.3 
      </B>- Execute a Program</A> </FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 
height=20></TD></TR></TBODY></TABLE></CENTER></DIV>
<H3><STRONG><FONT face=Arial size=3>13.3.6 MS-DOS Memory Management 
Functions</FONT></STRONG></H3>
<P><FONT face=Arial size=2>MS-DOS provides three memory management functions- 
allocate, deallocate, and resize (modify). For most programs, these three memory 
allocation calls are not used. When DOS executes a program, it gives all of the 
available memory, from the start of that program to the end of RAM, to the 
executing process. Any attempt to allocate memory without first giving unused 
memory back to the system will produce an "insufficient memory" error. 
</FONT></P>
<P><FONT face=Arial size=2>Sophisticated programs which terminate and remain 
resident, run other programs, or perform complex memory management tasks, may 
require the use of these memory management functions. Generally these types of 
programs immediately deallocate all of the memory that they don't use and then 
begin allocating and deallocating storage as they see fit. </FONT></P>
<P><FONT face=Arial size=2>Since these are complex functions, they shouldn't be 
used unless you have a very specific purpose for them. Misusing these commands 
may result in loss of system memory that can be reclaimed only by rebooting the 
system. Each of the following calls returns the error status in the carry flag. 
If the carry is clear on return, then the operation was completed successfully. 
If the carry flag is set when DOS returns, then the <CODE>ax </CODE>register 
contains one of the following error codes:</FONT></P><PRE><FONT face="Courier New" size=2>7- Memory control blocks destroyed 
8- Insufficient memory
9- Invalid memory block address</FONT></PRE>
<P><FONT face=Arial size=2>Additional notes about these errors will be discussed 
as appropriate.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-10></A>13.3.6.1 Allocate 
Memory</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  48h
Entry parameters:       bx- Requested block size (in paragraphs)
Exit parameters:        If no error (carry clear): 
                                ax:0 points at allocated memory block 

                        If an error (carry set):
                                bx- maximum possible allocation size
                                ax- error code (7 or 8)</FONT></PRE>
<P><FONT face=Arial size=2>This call is used to allocate a block of memory. On 
entry into DOS, <CODE>bx </CODE>contains the size of the requested block in 
paragraphs (groups of 16 bytes). On exit, assuming no error, the <CODE>ax 
</CODE>register contains the segment address of the start of the allocated 
block. If an error occurs, the block is not allocated and the <CODE>ax 
</CODE>register is returned containing the error code. If the allocation request 
failed due to insufficient memory, the <CODE>bx </CODE>register is returned 
containing the maximum number of paragraphs actually available.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-21></A>13.3.6.2 Deallocate 
Memory</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):          49h
Entry parameters:       es:0- Segment address of block to be deallocated
Exit parameters:        If the carry is set, ax contains the error code (7,9)</FONT></PRE>
<P><FONT face=Arial size=2>This call is used to deallocate memory allocated via 
function 48h above. The <CODE>es </CODE>register cannot contain an arbitrary 
memory address. It must contain a value returned by the allocate memory 
function. You cannot use this call to deallocate a portion of an allocated 
block. The modify allocation function is used for that operation.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-27></A>13.3.6.3 Modify 
Memory Allocation</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):          4Ah
Entry parameters:       es:0- address of block to modify allocation size
                        bx- size of new block
Exit parameters:        If the carry is set, then 
                        ax contains the error code 7, 8, or 9
                        bx contains the maximum size possible (if error 8)</FONT></PRE>
<P><FONT face=Arial size=2>This call is used to change the size of an allocated 
block. On entry, <CODE>es </CODE>must contain the segment address of the 
allocated block returned by the memory allocation function. <CODE>Bx </CODE>must 
contain the new size of this block in paragraphs. While you can almost always 
reduce the size of a block, you cannot normally increase the size of a block if 
other blocks have been allocated after the block being modified. Keep this in 
mind when using this function.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-36></A>13.3.6.4 Advanced 
Memory Management Functions</FONT></STRONG></P>
<P><FONT face=Arial size=2>The MS-DOS 58h opcode lets programmers adjust MS-DOS' 
memory allocation strategy and control the use of upper memory blocks (UMBs). 
There are four subfunctions to this call, with the subfunction value appearing 
in the al register. The following table describes these calls:</FONT></P>
<DIV align=center>
<CENTER>
<TABLE borderColor=#c0c0c0 cellSpacing=0 cellPadding=0 width="100%" border=1>
  <CAPTION><FONT face=Arial size=2><STRONG>Advanced Memory Management 
  Functions</STRONG></FONT></CAPTION>
  <TBODY>
  <TR>
    <TH align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial size=2>Function 
      # (AH)</FONT></STRONG></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial size=2>Input 
      Parameters</FONT></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial size=2>Output 
      Parameters</FONT></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial 
    size=2>Description</FONT></TH></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>58h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>-0</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>ax</CODE>- strategy</FONT></TD>
    <TD><FONT face=Arial size=2>Get Allocation Strategy: Returns the current 
      allocation strategy in ax (see table below for details).</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>58h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>al-1 bx</CODE>- strategy</FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Set Allocation Strategy: Sets the MS-DOS 
      allocation strategy to the value specified in bx (see the table below for 
      details).</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>58H</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- 2</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- link flag</FONT></TD>
    <TD><FONT face=Arial size=2>Get Upper Memory Link: Returns true/false 
      (1/0) in al to determine whether a program can allocate memory in the 
      upper memory blocks.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>58h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>al- 3 bx</CODE>- link flag (0=no link, 
      1=link okay).</FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Set Upper Memory Link: Links or unlinks the 
      upper memory area. When linked, an application can allocate memory from 
      the UMB (using the normal DOS allocate call). 
</FONT></TD></TR></TBODY></TABLE></CENTER></DIV>
<P>&nbsp;</P>
<DIV align=center>
<CENTER>
<TABLE borderColor=#c0c0c0 cellSpacing=0 cellPadding=0 width="100%" border=1>
  <CAPTION><FONT face=Arial size=2><STRONG>Memory Allocation 
  Strategies</STRONG></FONT></CAPTION>
  <TBODY>
  <TR>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial size=2>Value</FONT></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial size=2>Name</FONT></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial 
    size=2>Description</FONT></TH></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>0</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>First Fit Low</FONT></TD>
    <TD><FONT face=Arial size=2>Search conventional memory for the first free 
      block of memory large enough to satisfy the allocation request. This is 
      the default case.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>1</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>Best Fit Low</FONT></TD>
    <TD><FONT face=Arial size=2>Search conventional memory for the smallest 
      block large enough to satisfy the request.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>2</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>Last Fit Low</FONT></TD>
    <TD><FONT face=Arial size=2>Search conventional memory from the highest 
      address downward for the first block large enough to satisfy the 
      request.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>80h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>First Fit High</FONT></TD>
    <TD><FONT face=Arial size=2>Search high memory, then conventional memory, 
      for the first available block that can satisfy the allocation 
      request.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>81h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>Best Fit High</FONT></TD>
    <TD><FONT face=Arial size=2>Search high memory, then conventional memory 
      for the smallest block large enough to satisfy the allocation 
      request.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>82h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>Last Fit High</FONT></TD>
    <TD><FONT face=Arial size=2>Search high memory from high addresses to low, 
      then conventional memory from high addresses to low, for the first block 
      large enough to satisfy the request.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>40h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>First Fit Highonly</FONT></TD>
    <TD><FONT face=Arial size=2>Search high memory only for the first block 
      large enough to satisfy the request.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>41h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>Best Fit Highonly</FONT></TD>
    <TD><FONT face=Arial size=2>Search high memory only for the smallest block 
      large enough to satisfy the request.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>42h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2>Last Fit Highonly</FONT></TD>
    <TD><FONT face=Arial size=2>Search high memory only, from the end of 
      memory downward, for the first block large enough to satisfy the 
      request.</FONT></TD></TR></TBODY></TABLE></CENTER></DIV>
<P><FONT face=Arial size=2>These different allocation strategies can have an 
impact on system performance. For an analysis of different memory management 
strategies, please consult a good operating systems theory text.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-41></A>13.3.7 MS-DOS Process 
Control Functions</FONT></STRONG></P>
<P><FONT face=Arial size=2>DOS provides several services dealing with loading, 
executing, and terminating programs. Many of these functions have been rendered 
obsolete by later versions of DOS. There are three<A 
href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#FOOTNOTE-5">[5]</A> 
functions of general interest- program termination, terminate and stay resident, 
and execute a program. These three functions will be discussed in the following 
sections.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-43></A>13.3.7.1 Terminate 
Program Execution</FONT></STRONG></P>
<P><FONT face="Courier New" size=2>Function (ah):&nbsp;&nbsp;&nbsp;&nbsp; 
4Ch<BR>Entry parameters:&nbsp; al- return code<BR>Exit parameters:&nbsp;&nbsp; 
Does not return to your program</FONT></P>
<P><FONT face=Arial size=2>This is the function call normally used to terminate 
your program. It returns control to the calling process (normally, but not 
necessarily, DOS). A return code can be passed to the calling process in the 
<CODE>al </CODE>register. Exactly what meaning this return code has is entirely 
up to you. This return code can be tested with the DOS "IF ERRORLEVEL return 
code" command in a DOS batch file. All files opened by the current process will 
be automatically closed upon program termination.</FONT></P>
<P><FONT face=Arial size=2>Note that the UCR Standard Library function 
"<CODE>ExitPgm</CODE>" is simply a macro which makes this particular DOS call. 
This is the normal way of returning control back to MS-DOS or some other program 
which ran the currently active application.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-50></A>13.3.7.2 Terminate, 
but Stay Resident</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):          31h
Entry parameters:       al- return code
                        dx- memory size, in paragraphs
Exit parameters:        does not return to your program</FONT></PRE>
<P><FONT face=Arial size=2>This function also terminates program execution, but 
upon returning to DOS, the memory in use by the process is not returned to the 
DOS free memory pool. Essentially, the program remains in memory. Programs which 
remain resident in memory after returning to DOS are often called TSRs 
(terminate and stay resident programs). </FONT></P>
<P><FONT face=Arial size=2>When this command is executed, the <CODE>dx 
</CODE>register contains the number of memory paragraphs to leave around in 
memory. This value is measured from the beginning of the "program segment 
prefix", a segment marking the start of your file in memory. The address of the 
PSP (program segment prefix) is passed to your program in the <CODE>ds 
</CODE>register when your program is first executed. You'll have to save this 
value if your program is a TSR<A 
href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html#FOOTNOTE-6">[6]</A>. 
</FONT></P>
<P><FONT face=Arial size=2>Programs that terminate and stay resident need to 
provide some mechanism for restarting. Once they return to DOS they cannot 
normally be restarted. Most TSRs patch into one of the interrupt vectors (such 
as a keyboard, printer, or serial interrupt vector) in order to restart whenever 
some hardware related event occurs (such as when a key is pressed). This is how 
"pop-up" programs like SmartKey work. </FONT></P>
<P><FONT face=Arial size=2>Generally, TSR programs are pop-ups or special device 
drivers. The TSR mechanism provides a convenient way for you to load your own 
routines to replace or augment BIOS' routines. Your program loads into memory, 
patches the appropriate interrupt vector so that it points at an interrupt 
handler internal to your code, and then terminates and stays resident. Now, when 
the appropriate interrupt instruction is executed, your code will be called 
rather than BIOS'. </FONT></P>
<P><FONT face=Arial size=2>There are far too many details concerning TSRs 
including compatibility issues, DOS re-entrancy issues, and how interrupts are 
processed, to be considered here. Additional details will appear in a later 
chapter.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING5-61></A>13.3.7.3 Execute a 
Program</FONT></STRONG></P>
<P><FONT face="Courier New" size=2>Function (ah): 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40h<BR>Entry 
parameters:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ds:dx- pointer to pathname of 
program to 
execute<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
es:bx- Pointer to parameter 
block<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
al- 0=load and execute, 1=load only, 3=load overlay.<BR>Exit 
parameters:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If carry is set, ax 
contains one of the following error 
codes:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
1- invalid function 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
2- file not 
found<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
5- access denied 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
8- not enough 
memory<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
10- bad environment 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
11- bad format</FONT></P>
<P><FONT face=Arial size=2>The execute (<CODE>exec</CODE>) function is an 
extremely complex, but at the same time, very useful operation. This command 
allows you to load or load and execute a program off of the disk drive. On entry 
into the <CODE>exec </CODE>function, the <CODE>ds:dx </CODE>registers contain a 
pointer to a zero terminated string containing the name of the file to be loaded 
or executed, <CODE>es:bx </CODE>points at a parameter block, and <CODE>al 
</CODE>contains zero or one depending upon whether you want to load and execute 
a program or simply load it into memory. On return, if the carry is clear, then 
DOS properly executed the command. If the carry flag is set, then DOS 
encountered an error while executing the command. </FONT></P>
<P><FONT face=Arial size=2>The filename parameter can be a full pathname 
including drive and subdirectory information. "B:\DIR1\DIR2\MYPGM.EXE" is a 
perfectly valid filename (remember, however, it must be zero terminated). The 
segmented address of this pathname is passed in the <CODE>ds:dx 
</CODE>registers. </FONT></P>
<P><FONT face=Arial size=2>The <CODE>es:bx </CODE>registers point at a parameter 
block for the <CODE>exec </CODE>call. This parameter block takes on three 
different forms depending upon whether a program is being loaded and executed 
(<CODE>al</CODE>=0), just loaded into memory (<CODE>al</CODE>=1), or loaded as 
an overlay (<CODE>al</CODE>=3). </FONT></P>
<P><FONT face=Arial size=2>If <CODE>al</CODE>=0, the <CODE>exec </CODE>call 
loads and executes a program. In this case the <CODE>es:bx </CODE>registers 
point at a parameter block containing the following values:</FONT></P><PRE><FONT face="Courier New" size=2>Offset  Description 
0       A word value containing the segment address of the default environment 
	  (usually this is set to zero which implies the use of the standard DOS
	  environment).
2       Double word pointer containing the segment address of a command line string.
6       Double word pointer to default FCB at address 5Ch
0Ah     Double word pointer to default FCB at address 6Ch</FONT></PRE>
<P><FONT face=Arial size=2>The environment area is a set of strings containing 
default pathnames and other information (this information is provided by DOS 
using the PATH, SET, and other DOS commands). If this parameter entry contains 
zero, then <CODE>exec </CODE>will pass the standard DOS environment on to the 
new procedure. If non-zero, then this parameter contains the segment address of 
the environment block that your process is passing on to the program about to be 
executed. Generally, you should store a zero at this address.</FONT></P>
<P><FONT face=Arial size=2>The pointer to the command string should contain the 
segmented address of a length prefixed string which is also terminated by a 
carriage return character (the carriage return character is not figured into the 
length of the string). This string corresponds to the data that is normally 
typed after the program name on the DOS command line. For example, if you're 
executing the linker automatically, you might pass a command string of the 
following form:</FONT></P><PRE><FONT face="Courier New" size=2>CmdStr          byte    16,"MyPgm+Routines /m",0dh</FONT></PRE>
<P><FONT face=Arial size=2>The second item in the parameter block must contain 
the segmented address of this string.</FONT></P>
<P><FONT face=Arial size=2>The third and fourth items in the parameter block 
point at the default FCBs. FCBs are used by the obsolete DOS filing commands, so 
they are rarely used in modern application programs. Since the data structures 
these two pointers point at are rarely used, you can point them at a group of 20 
zeros.</FONT></P>
<P><FONT face=Arial size=2>Example: Format a floppy disk in drive A: using the 
FORMAT.EXE command</FONT></P><PRE><FONT face="Courier New" size=2>                mov     ah, 4Bh
                mov     al, 0
                mov     dx, seg PathName
                mov     ds, dx
                lea     dx, PathName
                mov     bx, seg ParmBlock
                mov     es, bx
                lea     bx, ParmBlock
                int     21h
                 .
                 .
                 .
PathName        byte    'C:\DOS\FORMAT.EXE',0
ParmBlock       word    0                       ;Default environment
                dword   CmdLine                 ;Command line string
                dword   Dummy,Dummy             ;Dummy FCBs

CmdLine         byte    3,' A:',0dh
Dummy           byte    20 dup (?)</FONT></PRE>
<P><FONT face=Arial size=2>MS-DOS versions earlier than 3.0 do not preserve any 
registers except cs:ip when you execute the exec call. In particular, ss:sp is 
not preserved. If you're using DOS v2.x or earlier, you'll need to use the 
following code: </FONT></P><PRE><FONT face="Courier New" size=2>;Example: Format a floppy disk in drive A: using the FORMAT.EXE command

                &lt;push any registers you need preserved&gt;

                mov     cs:SS_Save, ss          ;Save SS:SP to a location
                mov     cs:SP_Save, sp          ; we have access to later.
                mov     ah, 4Bh                 ;EXEC DOS opcode.
                mov     al, 0                   ;Load and execute.
                mov     dx, seg PathName        ;Get filename into DS:DX.
                mov     ds, dx
                lea     dx, PathName
                mov     bx, seg ParmBlock       ;Point ES:BX at parameter
                mov     es, bx                  ; block.
                lea     bx, ParmBlock
                int     21h
                mov     ss, cs:SS_Save          ;Restore SS:SP from saved
                mov     sp, cs:SP_Save          ; locations.

        &lt;Restore registers pushed onto the stack&gt;
                 .
                 .
                 .
SS_Save         word    ?
SP_Save         word    ?
                 .
                 .
                 .
PathName        byte    'C:\DOS\FORMAT.EXE',0
ParmBlock       word    0                       ;Default environment
                dword   CmdLine                 ;Command line string
                dword   Dummy,Dummy ;Dummy      ;FCBs
CmdLine         byte    3,' A:',0dh
Dummy           byte    20 dup (?)</FONT></PRE>
<P><FONT face=Arial size=2><CODE>SS_Save</CODE> and <CODE>SP_Save</CODE> must be 
declared inside your code segment. The other variables can be declared anywhere. 
</FONT></P>
<P><FONT face=Arial size=2>The <CODE>exec </CODE>command automatically allocates 
memory for the program being executed. If you haven't freed up unused memory 
before executing this command, you may get an insufficient memory error. 
Therefore, you should use the DOS deallocate memory command to free up unused 
memory before attempting to use the <CODE>exec </CODE>command. </FONT></P>
<P><FONT face=Arial size=2>If <CODE>al</CODE>=1 when the <CODE>exec 
</CODE>function executes, DOS will load the specified file but will not execute 
it. This function is generally used to load a program to execute into memory but 
give the caller control and let the caller start that code. When this function 
call is made, <CODE>es:bx </CODE>points at the following parameter block: 
</FONT></P><PRE><FONT face="Courier New" size=2>Offset  Description 
0       Word value containing the segment address of the environment block for the 
        new process. If you want to use the parent process' environment block set 
        this word to zero.

2       Dword pointer to the command tail for this operation. The command tail is the 
        command line string which will appear at location PSP:80.

6       Address of default FCB #1. For most programs, this should point at a block of 
        20 zeros (unless, of course, you're running a program which uses FCBs.).

0Ah     Address of default FCB #2. Should also point at a block of 20 zeros.

0Eh     SS:SP value. You must load these four bytes into SS and SP before starting 
        the application.

12h     CS:IP value. These four bytes contain the starting address of the program.</FONT></PRE>
<P><FONT face=Arial size=2>The <CODE>SSSP</CODE> and <CODE>CSIP</CODE> fields 
are output values. DOS fills in the fields and returns them in the load 
structure. The other fields are all inputs which you must fill in before calling 
the <CODE>exec </CODE>function with <CODE>al</CODE>=1.</FONT></P>
<P><FONT face=Arial size=2>When you execute the <CODE>exec </CODE>command with 
<CODE>al</CODE>=-3, DOS simply loads an overlay into memory. Overlays generally 
consist of a single code segment which contains some functions you want to 
execute. Since you are not creating a new process, the parameter block for this 
type of load is much simpler than for the other two types of load operations. On 
entry, <CODE>es:bx </CODE>must point at the following parameter block in 
memory:</FONT></P><PRE><FONT face="Courier New" size=2>Offset  Description 
0       Word value containing the segment address of where this file is going 
        to be loaded into memory.  The file will be loaded at offset zero within 
        this segment.

2       Word value containing a relocation factor for this file.</FONT></PRE>
<P><FONT face=Arial size=2>Unlike the load and execute functions, the overlay 
function does not automatically allocate storage for the file being loaded. Your 
program has to allocate sufficient storage and then pass the address of this 
storage block to the <CODE>exec </CODE>command (though the parameter block 
above). Only the segment address of this block is passed to the <CODE>exec 
</CODE>command, the offset is always assumed to be zero. The relocation factor 
should also contain the segment address for ".EXE" files. For ".COM" files, the 
relocation factor parameter should be zero.</FONT></P>
<P><FONT face=Arial size=2>The overlay command is quite useful for loading 
overlays from disk into memory. An overlay is a segment of code which resides on 
the disk drive until the program actually needs to execute its code. Then the 
code is loaded into memory and executed. Overlays can reduce the amount of 
memory your program takes up by allowing you to reuse the same portion of memory 
for different overlay procedures (clearly, only one such procedure can be active 
at any one time). By placing seldom-used code and initialization code into 
overlay files, you can help reduce the amount of memory used by your program 
file. One word of caution, however, managing overlays is a very complex task. 
This is not something a beginning assembly language programmer would want to 
tackle right away. When loading a file into memory (as opposed to loading and 
executing a file), DOS does not scramble all of the registers, so you needn't 
take the extra care necessary to preserve the <CODE>ss:sp </CODE>and other 
registers. </FONT></P>
<P><FONT face=Arial size=2>The MS-DOS Encyclopedia contains an excellent 
description of the use of the <CODE>exec </CODE>function.</FONT></P>
<HR color=#000000 noShade SIZE=1>

<P><FONT face=Arial size=2><STRONG><A name=FOOTNOTE-5></A>[5] </STRONG>Actually, 
there are others. See the DOS technical reference manual for more details. We 
will only consider these three here. </FONT></P>
<P><FONT face=Arial size=2><STRONG><A name=FOOTNOTE-6></A>[6]</STRONG> DOS also 
provides a call which will return the PSP for your program. </FONT></P>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 5)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html">Chapter 
      Thirteen</A> (Part 4)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html">Chapter 
      Thirteen</A> (Part 6)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 5)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<P align=right><FONT face=Arial size=2><STRONG>Chapter Thirteen: MS-DOS, PC-BIOS 
and File I/O (Part 5)<BR>28 SEP 1996</STRONG></FONT></P></BODY></HTML>
