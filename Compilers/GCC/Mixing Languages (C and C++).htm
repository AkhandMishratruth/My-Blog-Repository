<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0054)http://www.digitalmars.com/ctg/ctgMixingLanguages.html -->
<HTML><HEAD><TITLE>Digital Mars - Mixing Languages</TITLE><!--
	Copyright (c) 2001-2006 by Digital Mars
	All Rights Reserved
	www.digitalmars.com
  -->
<META http-equiv=content-type content="text/html; charset=utf-8"><LINK 
href="Mixing Languages (C and C++)-Dateien/style.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2900.2873" name=GENERATOR></HEAD>
<BODY>
<DIV id=heading><A href="http://www.digitalmars.com/"><IMG height=53 
alt=www.digitalmars.com src="Mixing Languages (C and C++)-Dateien/dmlogo.gif" 
width=270 border=0></A> <A title=www.digitalmars.com 
href="http://www.digitalmars.com/">Home</A> | <A 
title="Search Digital Mars web site" 
href="http://www.digitalmars.com/advancedsearch.html">Search</A> | <A 
title="Compiler &amp; Tools Guide" 
href="http://www.digitalmars.com/ctg/ctg.html">CTG</A> | <A 
title="Runtime Library Reference" 
href="http://www.digitalmars.com/rtl/rtl.html">RTL</A> | <A 
title="IDDE Reference" href="http://www.digitalmars.com/ugr/ugr.html">IDDE</A> | 
<A title="Standard Template Library" 
href="http://www.digitalmars.com/stl/index.html">STL</A> 
<DIV id=lastupdate>Last update Sat Apr 8 23:54:05 2006 </DIV></DIV><!-- Generated by Ddoc from ctgMixingLanguages.d -->
<TABLE cellSpacing=0 cellPadding=8 summary="this table is for layout only" 
border=1 frame=void>
  <TBODY>
  <TR>
    <TD class=toc vAlign=top noWrap><SMALL>
      <CENTER>
      <FORM action=http://www.google.com/search method=get><INPUT id=q 
      onfocus='if(this.value == "Search"){this.value="";}' size=10 value=Search 
      name=q> <INPUT id=domains type=hidden value=www.digitalmars.com 
      name=domains> <INPUT id=sitesearch type=hidden 
      value=www.digitalmars.com/ctg name=sitesearch> <INPUT id=sourceid 
      type=hidden value=google-search name=sourceid> <INPUT id=submit type=submit value=Go name=submit> </FORM></CENTER><A 
      href="http://www.digitalmars.com/ctg/ctg.html"><B>Compiler &amp; Tools 
      Guide</B></A><BR>
      <HR>
      <B>Compiling</B><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgCompilingCode.html">Compiling 
      Code</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/C-Language-Implementation.html">C 
      Implementation</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/CPP-Language-Implementation.html">C++ 
      Implementation</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgLanguageImplementation.html">Language 
      Extensions</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgMixingLanguages.html">Mixing 
      Languages</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgAsm.html">Assembly 
      Language</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgInlineAsm.html">Inline 
      Assembler</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgOptimizer.html">Optimizing 
      Code</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgNumerics.html">Numerics 
      Programming</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/regular.html">Regular 
      Expressions</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/acrtused.html">Acrtused</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/pragmas.html">Pragmas</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/precompiled.html">Precompiled 
      Headers</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/predefined.html">Predefined 
      Macros</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/warnings.html">Warning 
      Messages</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgCompilerErrors.html">Error 
      Messages</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/warnings.html#runtime">Runtime 
      Messages</A><BR><BR>
      <HR>
      <B>Linking</B><BR>• <A 
      href="http://www.digitalmars.com/ctg/optlink.html">Optlink</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgLinkSwitches.html">Switches</A><BR>• 
      <A href="http://www.digitalmars.com/ctg/ctgDefFiles.html">Module 
      Definition Files</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgLinkOps.html">Operation and 
      Design</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/OptlinkErrorMessages.html">Error 
      Messages</A><BR><BR>
      <HR>
      <B>Win32 Programming</B><BR>• <A 
      href="http://www.digitalmars.com/ctg/win32programming.html#win32">Win32 
      Programming</A><BR><BR>
      <HR>
      <B>DOS and Win16<BR>Programming</B><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgMemoryModel.html">Memory 
      Models</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/pointers16.html">16 Bit Pointer 
      Types<BR>and Type Modifiers</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/win32programming.html#handle">Handle 
      Pointers</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/win32programming.html#dos">DOS</A><BR>• 
      <A href="http://www.digitalmars.com/ctg/dos32.html">DOS 32 (DOSX)</A><BR>• 
      <A 
      href="http://www.digitalmars.com/ctg/win32programming.html#win16">Win16</A><BR>• 
      <A 
      href="http://www.digitalmars.com/ctg/win32programming.html#win16dll">Win16 
      DLLs</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/windowspe.html">Win16 
      Prolog/Epilog</A><BR><BR>
      <HR>
      <B>C/C++ Extensions</B><BR>• <A 
      href="http://www.digitalmars.com/ctg/contract.html">Contract 
      Programming</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/debugstatement.html">__debug 
      statement</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/debugstatement.html#debugdeclaration">__debug 
      declaration</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/trace.html">Dynamic 
      Profiling</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/html.html">Embedding C in 
      HTML</A><BR><BR>
      <HR>
      <B>Tools</B><BR>• <A title="Convert Borland compiler commands" 
      href="http://www.digitalmars.com/ctg/bcc.html">BCC</A><BR>• <A 
      title="Examine and change file attributes" 
      href="http://www.digitalmars.com/ctg/chmod.html">CHMOD</A><BR>• <A 
      title="Convert Microsoft compiler commands" 
      href="http://www.digitalmars.com/ctg/cl.html">CL</A><BR>• <A 
      title="Convert COFF .obj and .lib to OMF" 
      href="http://www.digitalmars.com/ctg/coff2omf.html">COFF2OMF</A><BR>• <A 
      title="Convert COFF import library OMF" 
      href="http://www.digitalmars.com/ctg/coffimplib.html">COFFIMPLIB</A><BR>• 
      <A title="Compiler command" 
      href="http://www.digitalmars.com/ctg/sc.html">DMC</A><BR>• <A 
      title="Compare files" 
      href="http://www.digitalmars.com/ctg/diff.html">DIFF</A><BR>• <A 
      title="Compare directories" 
      href="http://www.digitalmars.com/ctg/diffdir.html">DIFFDIR</A><BR>• <A 
      title="Dump files in hex" 
      href="http://www.digitalmars.com/ctg/dump.html">DUMP</A><BR>• <A 
      title="Dump object files in hex" 
      href="http://www.digitalmars.com/ctg/dumpobj.html">DUMPOBJ</A><BR>• <A 
      title="Dump exe files" 
      href="http://www.digitalmars.com/ctg/dumpexe.html">DUMPEXE</A><BR>• <A 
      title="Create .com files" 
      href="http://www.digitalmars.com/ctg/exe2bin.html">EXE2BIN</A><BR>• <A 
      title="Read/Write Floppy Image" 
      href="http://www.digitalmars.com/ctg/flpyimg.html">FLPYIMG</A><BR>• <A 
      title="Search files for string" 
      href="http://www.digitalmars.com/ctg/grep.html">GREP</A><BR>• <A 
      title="Creating Help Tools" 
      href="http://www.digitalmars.com/ctg/ctgHelp.html">HC</A><BR>• <A 
      title="Build import libraries" 
      href="http://www.digitalmars.com/ctg/implib.html">IMPLIB</A><BR>• <A 
      title="Object file librarian" 
      href="http://www.digitalmars.com/ctg/lib.html">LIB</A><BR>• <A 
      title="Analyze library and object files" 
      href="http://www.digitalmars.com/ctg/libunres.html">LIBUNRES</A><BR>• <A 
      title="Simple make utility" 
      href="http://www.digitalmars.com/ctg/make.html">MAKE</A><BR>• <A 
      title="Update makefile dependencies" 
      href="http://www.digitalmars.com/ctg/makedep.html">MAKEDEP</A><BR>• <A 
      title="MicroEmacs Text Editor" 
      href="http://www.digitalmars.com/ctg/me.html">ME</A><BR>• <A 
      title="Object file disassembler" 
      href="http://www.digitalmars.com/ctg/obj2asm.html">OBJ2ASM</A><BR>• <A 
      title="Patch object files" 
      href="http://www.digitalmars.com/ctg/patchobj.html">PATCHOBJ</A><BR>• <A 
      title="Microsoft Resource compiler" 
      href="http://www.digitalmars.com/ctg/ctgRC.html">RC</A><BR>• <A 
      title="Digital Mars Resource compiler" 
      href="http://www.digitalmars.com/ctg/rcc.html">RCC</A><BR>• <A 
      title="Compiler command" 
      href="http://www.digitalmars.com/ctg/sc.html">SC</A><BR>• <A 
      title="Shell scripts" 
      href="http://www.digitalmars.com/ctg/shell.html">SHELL</A><BR>• <A 
      title="Manage complex projects" 
      href="http://www.digitalmars.com/ctg/smake.html">SMAKE</A><BR>• <A 
      title="Set file timestamps" 
      href="http://www.digitalmars.com/ctg/touch.html">TOUCH</A><BR>• <A 
      title="Format C++ mangled names" 
      href="http://www.digitalmars.com/ctg/unmangle.html">UNMANGLE</A><BR>• <A 
      title="Search for files" 
      href="http://www.digitalmars.com/ctg/whereis.html">WHEREIS</A><BR><BR>
      <HR>
      <B>Porting to DMC++</B><BR>• <A 
      href="http://www.digitalmars.com/ctg/switchtodigitalmars.html">Switching 
      to DMC++</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/switchtodigitalmars.html#microsoft">from 
      Microsoft</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/switchtodigitalmars.html#borland">from 
      Borland</A><BR>• <A 
      href="http://www.digitalmars.com/ctg/ctgPorting.html">Porting 
      Guide</A><BR><BR></SMALL>
      <HR>

      <SCRIPT type=text/javascript><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_alternate_color = "eeeeee";
/**/google_ad_width = 120;
/**/google_ad_height = 90;
/**/google_ad_format = "120x90_0ads_al_s";
/**/google_ad_channel ="3448066137";
/**/google_color_border = "000000";
/**/google_color_bg = "F0F0F0";
/**/google_color_link = "0000FF";
/**/google_color_url = "008000";
/**/google_color_text = "000000";
//--></SCRIPT>

      <SCRIPT src="Mixing Languages (C and C++)-Dateien/show_ads.js" 
      type=text/javascript>
</SCRIPT>
    </TD>
    <TD vAlign=top>
      <H1>Mixing Languages</H1>Digital Mars C++ supports linkage with C, 
      FORTRAN, and Pascal functions. This chapter describes the function-naming 
      and parameter-passing conventions for linking these languages. It also 
      details the implementation of type-safe linkage, which allows the linker 
      to check the types of function arguments across separately compiled 
      modules and lets the programmer use the same function name for different 
      functions. 
      <P>For information about calling assembly language routines from C or C++, 
      see <A href="http://www.digitalmars.com/ctg/ctgAsm.html">Using Assembly 
      Language Functions</A>. 
      <H3>What's in This Chapter</H3>
      <UL>
        <LI>Type-safe linkage. 
        <LI>C++ linkage. 
        <LI>C linkage. 
        <LI>Mixing C and C++ modules. 
        <LI>Name mangling in C++. 
        <LI>Fortran and Pascal linkage. </LI></UL>
      <H2>Type-Safe Linkage</H2>The Digital Mars C++ implementation of type-safe 
      linkage is designed to make it easy to call, from a C++ program, a 
      function written in another language or vice versa. The system Digital 
      Mars uses is identical to the one described in the Microsoft Object 
      Mapping Specification, published by Microsoft's Language Business Unit. 
      <P>Type-safe linkage is an important feature of DMC++, even if only 
      linking C++ modules. It lets you overload functions (give different 
      functions the same name) because it provides the linker with a unique 
      identifier for each function. The compiler mangles the name you give a 
      function, in combination with the number and type of its arguments, to 
      produce a unique identifier for the linker. 
      <H3>Problems with traditional (unsafe) C linkage</H3>Traditional C linkage 
      mechanisms are unsafe because they give the compiler no viable way to 
      check the types of function arguments across separately compiled program 
      modules. This deficiency can cause serious problems at compile time. For 
      instance, suppose the following function is defined in a header file: <PRE>	void checkit(unsigned char c); 
</PRE>where c is defined as unsigned char because some of the values it 
      needs to check for are in the range 128 through 255. This header is 
      typically included in the file that defines checkit. 
      <P>As is also common in C programming, checkit is used in a second file. 
      Rather than include the header file, the programmer (per convention) 
      separately declares the prototype for checkit at the top of the second 
      file. The following prototype is used: </P><PRE>	void checkit(char c); 
</PRE>If the program is compiled on a system that uses unsigned chars by 
      default, the above code compiles and executed perfectly. However, if the 
      program is then ported to a compiler where chars are signed by default 
      (like DMC++), the program yields unpredictable results because the call to 
      checkit in the second file treats values over 127 as negative. 
      <P>Bugs of this type can prove very difficult to find because the compiler 
      processes one file at a time and therefore cannot detect type violations 
      in function prototypes across files. But with type-safe linkage, the 
      compiler generates two different internal (hidden) identifiers for the two 
      prototypes. Since no matching function is provided for the second 
      prototype, the linker flags this external function reference as 
      unresolved. 
      <H3>Advantages of type-safe linkage</H3>Type-safe linkage offers these 
      important advantages over traditional C linkage: 
      <UL>
        <LI>You can overload C++ functions without using the overload keyword. 
        <LI>The linker automatically checks the types of function arguments 
        across modules. 
        <LI>The compiler provides improved error checking and error reporting 
        with respect to type mismatches. </LI></UL>This system still allows 
      linkage to external libraries and precompiled C code without having to 
      recompile them. It is also more flexible than modifying function linkage 
      with the __cdecl, __pascal, or __fortran keywords alone. However, each 
      linkage type (Digital Mars C++ supports FORTRAN and Pascal linkage, in 
      addition to the built-in C++ and C linkage specifications) differs from 
      the others in function-naming, parameter-passing conventions, or both, 
      depending on the target environment. 
      <H2>C++ Linkage</H2>C++ linkage is the linkage type the C++ compiler uses 
      by default. 
      <H3>Function naming</H3>The C++ compiler mangles the names of functions 
      with C++ linkage to include information on the number and types of 
      arguments they take. For member functions, information as to the class to 
      which a function belongs is also included. 
      <H3>Overloading</H3>All functions are automatically overloaded. Whenever a 
      new version of a function is defined, it must have a prototype that the 
      compiler can distinguish; otherwise, it cannot be overloaded. Because the 
      internal name for each function is unique, the compiler can resolve a 
      function call to the correct version of the overloaded function, even if 
      it occurs in a third-party external library. Since the overloading of 
      functions is automatic, the overload keyword is redundant (although it is 
      still allowed). Do not use the overload keyword in new code because it 
      could be removed from the C++ language definition. 
      <P>If you accidentally overload a function (that is, if you declare it 
      twice with different argument types), one of these functions will not have 
      a function definition with matching argument types, and the linker will 
      report an unresolved external reference. This happens even if the 
      re-declarations occur in two separately compiled modules. 
      <H3>How the compiler treats functions with C++ linkage</H3>The compiler 
      performs these operations on functions with C++ linkage: 
      <UL>
        <LI>It mangles all function names (that is, type information is appended 
        to the function name). 
        <LI>For functions that take a fixed number of arguments: 
        <UL>
          <LI>It pushes arguments from left to right onto the stack before the 
          function is called (the rightmost argument is closest to the stack 
          pointer). 
          <LI>The called function (not the caller) cleans the arguments off the 
          stack. On 8086-based processors, this is accomplished via the RET N 
          instruction, where N is the number of bytes on the stack. 
          <LI>It returns structures by allocating a temporary variable on the 
          stack and passing a hidden pointer to it. The called function copies 
          the return values into the temporary variable and returns a pointer to 
          it. This method is reentrant. 
          <LI>It returns floats and doubles in registers (unlike Microsoft C). 
          This method is reentrant. </LI></UL>
        <LI>For functions that take a variable number of arguments: 
        <UL>
          <LI>It pushes arguments from right to left onto the stack before the 
          function is called (the leftmost argument is closest to the stack 
          pointer). 
          <LI>The caller of the function cleans the arguments off the stack. 
          <LI>It returns floats and doubles in registers (unlike Microsoft C). 
          This method is reentrant. 
          <LI>It returns structures that are 1, 2, or 4 bytes long in registers. 
          Larger structures are returned by creating a temporary variable in a 
          static buffer, copying the return value into the buffer, and returning 
          a pointer to it. This method is not reentrant. </LI></UL></LI></UL>
      <H3>Mixing C++ linkage with other linkage types</H3>C does not support C++ 
      linkage. You can call C functions from C++ code but you cannot call C++ 
      functions from C code. With the C++ compiler, you can use the syntax: <PRE>	extern "C++" { } 
</PRE>to specify C++ linkage when the declaration of a C++ function is 
      nested inside declarations for some other linkage type. See the section 
      "Type-Safe Linkage" in this chapter for more information. 
      <P><B>Note:</B> The __near and __far keywords are ignored for member 
      functions and always use the default for the memory model used. This 
      behavior simplifies the implementation of virtual functions. 
      <H2>C Linkage</H2>The C linkage method allows programs written in C++ to 
      link with and call C library functions. C linkage has the same effect with 
      the C++ compiler as the __cdecl keyword has with the C compiler. 
      <P>C linkage is the default linkage for .c files when compiled without the 
      -cpp flag. If a function is declared as using C linkage, and a function 
      definition is found in the C++ source file, that function is compiled as a 
      C function and not as a C++ function. Any calls to that function from 
      other C++ functions are handled correctly. 
      <P>Digital Mars's C linkage is compatible with the C linkage used by the 
      Microsoft C compiler. 
      <H3>How the compiler treats functions with C linkage</H3>The compiler 
      treats functions with C linkage as follows: 
      <UL>
        <LI>It prefixes an underscore (_) to all global names. 
        <LI>It does not mangle function names. 
        <LI>It pushes arguments from right to left onto the stack before the 
        function is called (the leftmost argument is closest to the stack 
        pointer). 
        <LI>The caller of the function cleans the arguments off the stack. 
        <LI>It returns structures that are 1, 2, or 4 bytes long in registers. 
        It returns larger structures by creating a temporary variable in a 
        static buffer and passing a hidden pointer to it. This method is not 
        reentrant. 
        <LI>It returns floats and doubles in registers (unlike Microsoft C). 
        This method is reentrant. </LI></UL>
      <H3>Specifying C linkage in C++ code</H3>In C++ code, use this syntax to 
      specify C linkage: <PRE>	extern "C" { } 
</PRE>In C code, you can specify C linkage explicitly by using the __cdecl 
      type modifier, provided you do not require strict ANSI C compatibility. 
      <P><B>Note:</B> The compiler recognizes the main function as special and 
      always compiles it with C linkage. 
      <H2>Mixing C and C++ Modules</H2>C++ lets you call a C function from a C++ 
      program. Only minor changes to header files typically are required. 
      Compatibility with existing source code Every effort has been made to 
      maximize compatibility between DMC++ and other C++ and C compilers, but 
      you may need to take some precautions when compiling code written with 
      other compilers. See Chapter 22, "Switching to Digital Mars C++," for 
      information. 
      <H3>Compatibility with earlier versions of Digital Mars C++</H3>Programs 
      that compiled under earlier versions of DMC++ should compile and run with 
      only minor modifications under Version 7. However, you need to recompile 
      all your code because of differences in the way the new compiler stores 
      objects in memory. You might also need to make some changes to header 
      files to account for the new compiler's more stringent type checking. 
      <H3>Recompiling C code as C++ code</H3>We recommend that you rename your C 
      modules with an extension that the compiler recognizes as a C++ file 
      extension, or compile with the -cpp switch, so that your C functions use 
      the default C++ linkage. This provides the benefit of cross-module type 
      checking for those functions. Recompiling C functions as C++ functions 
      also means an increase in speed because the compiler can use the more 
      efficient C++ parameter-passing method. 
      <P>If you wish to retain C linkage for functions that call assembly 
      language routines, remember to ensure that the interface to C++ is correct 
      (see <A href="http://www.digitalmars.com/ctg/ctgAsm.html">Using Assembly 
      Language Functions</A> for information). 
      <H3>Using existing C libraries</H3>If you need to link separately compiled 
      C and C++ object files, use an existing C library without having to 
      recompile it, or use assembly language routines that have been designed to 
      interface to C. You need to ensure that the C++ modules use the right 
      linking conventions when calling functions contained in C or assembly 
      language modules. 
      <P>Unless your C modules are compiled with a third-party C compiler, you 
      do not have to recompile them. Follow the steps below to generate an 
      object file and associated header files that you can link to both C and 
      C++ modules. All that is required is a modification of the associated 
      header files. 
      <P><B>Note:</B> When constructing makefiles, be sure to run the right 
      compiler for each file. The default extension for C files is .c. Valid 
      extensions for C++ files are .cpp, .cxx, or .cc. 
      <H3>Changing the header files</H3>To modify an existing C library to work 
      with Digital Mars C++, insert the following code at the beginning of each 
      header file: <PRE>	#ifdef __cplusplus
	extern "C" { 
	#endif 
</PRE>And, at then end of the file, insert this code: <PRE>	#ifdef __cplusplus
	} 
	#endif 
</PRE>You can then use the header with both C and C++ files. 
      <P>Where it is undesirable to modify the header file, you can use the 
      following technique to encapsulate the #include statement in the source 
      file: </P><PRE>	extern "C" {
	#include "c_header.h" 
	}
</PRE>
      <H3>Prototyping the functions in a library</H3>If, after linking your 
      program with a library, you get one or more linker error messages about 
      unprototyped functions, it is likely that not all of the functions 
      contained in the library are prototyped in the header files for the 
      library. You need to provide prototypes for those functions that do not 
      have them and place them in the header files. You know which functions 
      require prototyping by looking at the first part of the function name 
      reported by the linker, up to the underscore. The procedure is the same 
      for assembly language functions. 
      <P>Once you have modified a header file, you should be able to use the 
      library without difficulty, provided you always include the required 
      headers for the functions you use (as you must for the standard C 
      libraries supplied with the compiler). 
      <H2>Name Mangling in C++</H2>Name mangling refers to the way in which the 
      compiler alters function names internally so that it can track member 
      functions, function overloading, and argument types. 
      <P>The general layout for the DMC++ name mangling is described in the 
      Microsoft Object Mapping Specification, published by Microsoft's Language 
      Business Unit. 
      <P>The basis for this name mangling is the function name itself, with an 
      added signature that holds information about the class (if any) to which 
      the function belongs and the number and types of its arguments. 
      <P>When constructing a C++ function name, the compiler takes the original 
      function name as the root of the encoded name. If the function being 
      encoded is a C++ operator, the compiler must also supply a function name 
      to represent the operator. 
      <P>To view the mangled names of your functions, compile them and then use 
      the <A href="http://www.digitalmars.com/ctg/dumpobj.html">DUMPOBJ</A> or 
      <A href="http://www.digitalmars.com/ctg/obj2asm.html">OBJ2ASM</A> 
      utilities to view the resulting object file, or link the code and run the 
      <A href="http://www.digitalmars.com/ctg/unmangle.html">UNMANGLE</A> 
      utility on the executable or map file. 
      <P>You can also examine mangled names in a compiled program with the 
      Digital Mars C debugger or with the Digital Mars C++ debugger in pure C 
      mode. 
      <H2>FORTRAN and Pascal Linkage</H2>The FORTRAN and Pascal linkage types 
      let you link C++ code to code written in other languages that use FORTRAN 
      or Pascal calling conventions. 
      <P>In DMC++, the FORTRAN and Pascal linkage types behave identically. 
      However, you should use the appropriate specifier for functions of each 
      type because the calling conventions for FORTRAN and Pascal may differ in 
      future releases or on other platforms. 
      <H3>Compilation of functions with FORTRAN/Pascal linkage</H3>The compiler 
      treats functions with FORTRAN or Pascal linkage as follows: 
      <UL>
        <LI>It does not prefix an underscore (_) to global names. 
        <LI>It converts all global names to uppercase. 
        <LI>It does not append type information to function names. 
        <LI>It pushes arguments onto the stack from left to right. 
        <LI>The called function cleans the stack. 
        <LI>Structures, floats, and doubles are returned by allocating a 
        temporary variable on the stack and passing a hidden pointer to it. The 
        called function copies the return values into this variable and returns 
        a pointer to it. This method is reentrant. </LI></UL>
      <H3>Specifying FORTRAN/Pascal linkage in C code</H3>In C code, use the 
      __pascal type modifier to get Pascal linkage and the __fortran type 
      modifier to get FORTRAN linkage, provided you do not require strict ANSI C 
      compatibility. 
      <H3>Specifying FORTRAN/Pascal linkage in C++ code</H3>In C++ code, use 
      this syntax to specify Pascal or FORTRAN linkage: <PRE>	extern "Pascal" { } 
</PRE>or <PRE>	extern "FORTRAN" { } 
</PRE>You cannot use the C++ syntax in C programs. 
      <P><B>Warning:</B> Although the FORTRAN and Pascal linkage methods allow 
      C++ programs to call functions of these types or vice versa, they do not 
      handle any other required conversions. For example, conversions of NULL- 
      terminated C++ strings into Pascal strings with a length prefix are not 
      automatic. 
      <H3>__cdecl, __fortran, and __pascal</H3>In Digital Mars C++, it is 
      possible to call functions that do not use the default function calling 
      conventions. For instance, system functions in the Microsoft Windows API 
      use Pascal calling conventions. The keywords __cdecl, __fortran, and 
      __pascal tell the C compiler that the functions to which they refer use 
      the calling and parameter-passing conventions of C, FORTRAN, or Pascal, 
      respectively, rather than the default conventions. In this respect, they 
      work in the same way as extern "C", extern "FORTRAN", and extern "Pascal" 
      do in the C++ compiler, except that the extern format also engages the 
      function-naming conventions of the indicated language. 
      <P><B>Note:</B> Although you can use these keywords in both C and C++, use 
      them with caution. The preferred method to use with C++ is the extern "C", 
      extern "FORTRAN" or extern "Pascal" syntax. This will make the C++ code 
      portable to other C++ compilers. 
      <P>For example, to declare Pascal-calling conventions in C: </P><PRE>	extern int __pascal my_function(); 
</PRE>in C++: <PRE>	extern "Pascal" int my_function(); 
</PRE>Declaring data as __cdecl, __fortran, or __pascal influences how the 
      name appears to the linker. However, the name always appears to the 
      debugger as it appears in the source. __cdecl causes an underscore to be 
      added to the front of the name, which is the default. __fortran or 
      __pascal causes the name to convert to upper case. For example, the 
      following code appears as blang to the linker: <PRE>	int __pascal blang; 
</PRE>Notice that the keyword appears immediately before the variable 
      name. 
      <P><B>Note:</B> If you do not use __cdecl, __fortran, __pascal, or the 
      extern functions, the compiler mangles variable names according to 
      Microsoft specifications. This deviates from the ARM description, which 
      recommends that names not be mangled. 
      <H3>Portability of Extended Keywords</H3>One useful method of ensuring 
      portability to other systems is by conditionally defining the extended 
      keywords as empty: <PRE>	// Remove extended keywords for non Digital Mars
	// compilers 

	#if !defined(__DMC__)
	#define __cdecl 
	#define __pascal
	#define __fortran 
	#endif 
</PRE><B>Note:</B> In general, function pointers can cause subtle problems 
      when the function pointed to is not the compiler's default type. The rule 
      to remember is that the extended keyword must appear immediately before 
      the *, which determines that the type is a function pointer. The correct 
      syntax for declaring a pointer to a Pascal function is: <PRE>	int (__pascal *fp)(void); 
</PRE><BR><BR><BR><BR><!-- Google ad -->
      <SCRIPT type=text/javascript><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_type = "text_image";
/**/google_ad_channel ="3448066137";
/**/google_page_url = document.location;
//--></SCRIPT>

      <SCRIPT src="Mixing Languages (C and C++)-Dateien/show_ads.js" 
      type=text/javascript>
</SCRIPT>
    </TD></TR></TBODY></TABLE>
<DIV id=copyright>Copyright © 1999-2006 by Digital Mars, All Rights Reserved | 
Page generated by <A href="http://www.digitalmars.com/d/ddoc.html">Ddoc</A>. 
</DIV></BODY></HTML>
