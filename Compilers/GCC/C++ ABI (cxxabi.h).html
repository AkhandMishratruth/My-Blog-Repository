<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0076)http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/cxxabi_8h-source.html -->
<HTML><HEAD><TITLE>libstdc++: cxxabi.h Source File</TITLE>
<META http-equiv=Content-Type content=text/html;charset=iso-8859-1><LINK 
href="libstdc++ - cxxabi-Dateien/style.css" type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.2873" name=GENERATOR></HEAD>
<BODY><!-- Generated by Doxygen 1.4.4 -->
<DIV class=nav><A class=el 
href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/dir_000006.html">src</A>&nbsp;»&nbsp;<A 
class=el 
href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/dir_000007.html">gcc</A>&nbsp;»&nbsp;<A 
class=el 
href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/dir_000008.html">libstdc++-v3</A>&nbsp;»&nbsp;<A 
class=el 
href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/dir_000009.html">libsupc++</A></DIV>
<H1>cxxabi.h</H1><A 
href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/cxxabi_8h.html">Go 
to the documentation of this file.</A>
<DIV class=fragment><PRE class=fragment><A name=l00001></A>00001 <SPAN class=comment>// new abi support -*- C++ -*-</SPAN>
<A name=l00002></A>00002   
<A name=l00003></A>00003 <SPAN class=comment>// Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.</SPAN>
<A name=l00004></A>00004 <SPAN class=comment>//</SPAN>
<A name=l00005></A>00005 <SPAN class=comment>// This file is part of GCC.</SPAN>
<A name=l00006></A>00006 <SPAN class=comment>//</SPAN>
<A name=l00007></A>00007 <SPAN class=comment>// GCC is free software; you can redistribute it and/or modify</SPAN>
<A name=l00008></A>00008 <SPAN class=comment>// it under the terms of the GNU General Public License as published by</SPAN>
<A name=l00009></A>00009 <SPAN class=comment>// the Free Software Foundation; either version 2, or (at your option)</SPAN>
<A name=l00010></A>00010 <SPAN class=comment>// any later version.</SPAN>
<A name=l00011></A>00011 <SPAN class=comment>// </SPAN>
<A name=l00012></A>00012 <SPAN class=comment>// GCC is distributed in the hope that it will be useful,</SPAN>
<A name=l00013></A>00013 <SPAN class=comment>// but WITHOUT ANY WARRANTY; without even the implied warranty of</SPAN>
<A name=l00014></A>00014 <SPAN class=comment>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</SPAN>
<A name=l00015></A>00015 <SPAN class=comment>// GNU General Public License for more details.</SPAN>
<A name=l00016></A>00016 <SPAN class=comment>// </SPAN>
<A name=l00017></A>00017 <SPAN class=comment>// You should have received a copy of the GNU General Public License</SPAN>
<A name=l00018></A>00018 <SPAN class=comment>// along with GCC; see the file COPYING.  If not, write to</SPAN>
<A name=l00019></A>00019 <SPAN class=comment>// the Free Software Foundation, 51 Franklin Street, Fifth Floor,</SPAN>
<A name=l00020></A>00020 <SPAN class=comment>// Boston, MA 02110-1301, USA.</SPAN>
<A name=l00021></A>00021 
<A name=l00022></A>00022 <SPAN class=comment>// As a special exception, you may use this file as part of a free software</SPAN>
<A name=l00023></A>00023 <SPAN class=comment>// library without restriction.  Specifically, if other files instantiate</SPAN>
<A name=l00024></A>00024 <SPAN class=comment>// templates or use macros or inline functions from this file, or you compile</SPAN>
<A name=l00025></A>00025 <SPAN class=comment>// this file and link it with other files to produce an executable, this</SPAN>
<A name=l00026></A>00026 <SPAN class=comment>// file does not by itself cause the resulting executable to be covered by</SPAN>
<A name=l00027></A>00027 <SPAN class=comment>// the GNU General Public License.  This exception does not however</SPAN>
<A name=l00028></A>00028 <SPAN class=comment>// invalidate any other reasons why the executable file might be covered by</SPAN>
<A name=l00029></A>00029 <SPAN class=comment>// the GNU General Public License.</SPAN>
<A name=l00030></A>00030 
<A name=l00031></A>00031 <SPAN class=comment>// Written by Nathan Sidwell, Codesourcery LLC, &lt;nathan@codesourcery.com&gt;</SPAN>
<A name=l00032></A>00032  
<A name=l00033></A>00033 <SPAN class=comment>/* This file declares the new abi entry points into the runtime. It is not</SPAN>
<A name=l00034></A>00034 <SPAN class=comment>   normally necessary for user programs to include this header, or use the</SPAN>
<A name=l00035></A>00035 <SPAN class=comment>   entry points directly. However, this header is available should that be</SPAN>
<A name=l00036></A>00036 <SPAN class=comment>   needed.</SPAN>
<A name=l00037></A>00037 <SPAN class=comment>   </SPAN>
<A name=l00038></A>00038 <SPAN class=comment>   Some of the entry points are intended for both C and C++, thus this header</SPAN>
<A name=l00039></A>00039 <SPAN class=comment>   is includable from both C and C++. Though the C++ specific parts are not</SPAN>
<A name=l00040></A>00040 <SPAN class=comment>   available in C, naturally enough.  */</SPAN>
<A name=l00041></A>00041 <SPAN class=comment></SPAN>
<A name=l00042></A>00042 <SPAN class=comment>/** @file cxxabi.h</SPAN>
<A name=l00043></A>00043 <SPAN class=comment> *  The header provides an interface to the C++ ABI.</SPAN>
<A name=l00044></A>00044 <SPAN class=comment> */</SPAN>
<A name=l00045></A>00045 
<A name=l00046></A>00046 <SPAN class=preprocessor>#ifndef _CXXABI_H</SPAN>
<A name=l00047></A><A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/cxxabi_8h.html#a0">00047</A> <SPAN class=preprocessor></SPAN><SPAN class=preprocessor>#define _CXXABI_H 1</SPAN>
<A name=l00048></A>00048 <SPAN class=preprocessor></SPAN>
<A name=l00049></A>00049 <SPAN class=preprocessor>#pragma GCC visibility push(default)</SPAN>
<A name=l00050></A>00050 <SPAN class=preprocessor></SPAN>
<A name=l00051></A>00051 <SPAN class=preprocessor>#include &lt;stddef.h&gt;</SPAN>
<A name=l00052></A>00052 <SPAN class=preprocessor>#include &lt;bits/cxxabi_tweaks.h&gt;</SPAN>
<A name=l00053></A>00053  
<A name=l00054></A>00054 <SPAN class=preprocessor>#ifdef __cplusplus</SPAN>
<A name=l00055></A>00055 <SPAN class=preprocessor></SPAN><SPAN class=keyword>namespace </SPAN>__cxxabiv1
<A name=l00056></A>00056 {  
<A name=l00057></A>00057   <SPAN class=keyword>typedef</SPAN> __cxa_cdtor_return_type (*__cxa_cdtor_type)(<SPAN class=keywordtype>void</SPAN> *);
<A name=l00058></A>00058 
<A name=l00059></A>00059   <SPAN class=keyword>extern</SPAN> <SPAN class=stringliteral>"C"</SPAN> 
<A name=l00060></A>00060   {
<A name=l00061></A>00061 <SPAN class=preprocessor>#endif</SPAN>
<A name=l00062></A>00062 <SPAN class=preprocessor></SPAN>
<A name=l00063></A>00063   <SPAN class=comment>// Allocate array.</SPAN>
<A name=l00064></A>00064   <SPAN class=keywordtype>void</SPAN>* 
<A name=l00065></A>00065   __cxa_vec_new(size_t __element_count, size_t __element_size, 
<A name=l00066></A>00066         size_t __padding_size, __cxa_cdtor_type constructor,
<A name=l00067></A>00067         __cxa_cdtor_type destructor);
<A name=l00068></A>00068 
<A name=l00069></A>00069   <SPAN class=keywordtype>void</SPAN>*
<A name=l00070></A>00070   __cxa_vec_new2(size_t __element_count, size_t __element_size,
<A name=l00071></A>00071          size_t __padding_size, __cxa_cdtor_type constructor,
<A name=l00072></A>00072          __cxa_cdtor_type destructor, <SPAN class=keywordtype>void</SPAN> *(*__alloc) (size_t), 
<A name=l00073></A>00073          <SPAN class=keywordtype>void</SPAN> (*__dealloc) (<SPAN class=keywordtype>void</SPAN>*));
<A name=l00074></A>00074 
<A name=l00075></A>00075   <SPAN class=keywordtype>void</SPAN>*
<A name=l00076></A>00076   __cxa_vec_new3(size_t __element_count, size_t __element_size,
<A name=l00077></A>00077          size_t __padding_size, __cxa_cdtor_type constructor,
<A name=l00078></A>00078          __cxa_cdtor_type destructor, <SPAN class=keywordtype>void</SPAN> *(*__alloc) (size_t), 
<A name=l00079></A>00079          <SPAN class=keywordtype>void</SPAN> (*__dealloc) (<SPAN class=keywordtype>void</SPAN>*, size_t));
<A name=l00080></A>00080 
<A name=l00081></A>00081   <SPAN class=comment>// Construct array.</SPAN>
<A name=l00082></A>00082   __cxa_vec_ctor_return_type
<A name=l00083></A>00083   __cxa_vec_ctor(<SPAN class=keywordtype>void</SPAN>* __array_address, size_t __element_count,
<A name=l00084></A>00084          size_t __element_size, __cxa_cdtor_type constructor,
<A name=l00085></A>00085          __cxa_cdtor_type destructor);
<A name=l00086></A>00086 
<A name=l00087></A>00087   __cxa_vec_ctor_return_type
<A name=l00088></A>00088   __cxa_vec_cctor(<SPAN class=keywordtype>void</SPAN>* dest_array, <SPAN class=keywordtype>void</SPAN>* src_array, size_t element_count, 
<A name=l00089></A>00089           size_t element_size, 
<A name=l00090></A>00090           __cxa_cdtor_return_type (*constructor) (<SPAN class=keywordtype>void</SPAN>*, <SPAN class=keywordtype>void</SPAN>*), 
<A name=l00091></A>00091           __cxa_cdtor_type destructor);
<A name=l00092></A>00092  
<A name=l00093></A>00093   <SPAN class=comment>// Destruct array.</SPAN>
<A name=l00094></A>00094   <SPAN class=keywordtype>void</SPAN> 
<A name=l00095></A>00095   __cxa_vec_dtor(<SPAN class=keywordtype>void</SPAN>* __array_address, size_t __element_count,
<A name=l00096></A>00096          size_t __element_size, __cxa_cdtor_type destructor);
<A name=l00097></A>00097   
<A name=l00098></A>00098   <SPAN class=keywordtype>void</SPAN> 
<A name=l00099></A>00099   __cxa_vec_cleanup(<SPAN class=keywordtype>void</SPAN>* __array_address, size_t __element_count,
<A name=l00100></A>00100             size_t __element_size, __cxa_cdtor_type destructor);
<A name=l00101></A>00101   
<A name=l00102></A>00102   <SPAN class=comment>// Destruct and release array.</SPAN>
<A name=l00103></A>00103   <SPAN class=keywordtype>void</SPAN> 
<A name=l00104></A>00104   __cxa_vec_delete(<SPAN class=keywordtype>void</SPAN>* __array_address, size_t __element_size,
<A name=l00105></A>00105            size_t __padding_size, __cxa_cdtor_type destructor);
<A name=l00106></A>00106 
<A name=l00107></A>00107   <SPAN class=keywordtype>void</SPAN> 
<A name=l00108></A>00108   __cxa_vec_delete2(<SPAN class=keywordtype>void</SPAN>* __array_address, size_t __element_size,
<A name=l00109></A>00109             size_t __padding_size, __cxa_cdtor_type destructor,
<A name=l00110></A>00110             <SPAN class=keywordtype>void</SPAN> (*__dealloc) (<SPAN class=keywordtype>void</SPAN>*));
<A name=l00111></A>00111                   
<A name=l00112></A>00112   <SPAN class=keywordtype>void</SPAN> 
<A name=l00113></A>00113   __cxa_vec_delete3(<SPAN class=keywordtype>void</SPAN>* __array_address, size_t __element_size,
<A name=l00114></A>00114             size_t __padding_size, __cxa_cdtor_type destructor,
<A name=l00115></A>00115             <SPAN class=keywordtype>void</SPAN> (*__dealloc) (<SPAN class=keywordtype>void</SPAN>*, size_t));
<A name=l00116></A>00116 
<A name=l00117></A>00117   <SPAN class=keywordtype>int</SPAN> 
<A name=l00118></A>00118   __cxa_guard_acquire(__guard*);
<A name=l00119></A>00119 
<A name=l00120></A>00120   <SPAN class=keywordtype>void</SPAN> 
<A name=l00121></A>00121   __cxa_guard_release(__guard*);
<A name=l00122></A>00122 
<A name=l00123></A>00123   <SPAN class=keywordtype>void</SPAN> 
<A name=l00124></A>00124   __cxa_guard_abort(__guard*);
<A name=l00125></A>00125 
<A name=l00126></A>00126   <SPAN class=comment>// Pure virtual functions.</SPAN>
<A name=l00127></A>00127   <SPAN class=keywordtype>void</SPAN>
<A name=l00128></A>00128   __cxa_pure_virtual(<SPAN class=keywordtype>void</SPAN>);
<A name=l00129></A>00129 
<A name=l00130></A>00130   <SPAN class=comment>// Exception handling.</SPAN>
<A name=l00131></A>00131   <SPAN class=keywordtype>void</SPAN>
<A name=l00132></A>00132   __cxa_bad_cast();
<A name=l00133></A>00133 
<A name=l00134></A>00134   <SPAN class=keywordtype>void</SPAN>
<A name=l00135></A>00135   __cxa_bad_typeid();
<A name=l00136></A>00136 
<A name=l00137></A>00137   <SPAN class=comment>// DSO destruction.</SPAN>
<A name=l00138></A>00138   <SPAN class=keywordtype>int</SPAN>
<A name=l00139></A>00139   __cxa_atexit(<SPAN class=keywordtype>void</SPAN> (*)(<SPAN class=keywordtype>void</SPAN>*), <SPAN class=keywordtype>void</SPAN>*, <SPAN class=keywordtype>void</SPAN>*);
<A name=l00140></A>00140 
<A name=l00141></A>00141   <SPAN class=keywordtype>int</SPAN>
<A name=l00142></A>00142   __cxa_finalize(<SPAN class=keywordtype>void</SPAN>*);
<A name=l00143></A>00143 
<A name=l00144></A>00144   <SPAN class=comment>// Demangling routines. </SPAN>
<A name=l00145></A>00145   <SPAN class=keywordtype>char</SPAN>*
<A name=l00146></A>00146   __cxa_demangle(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __mangled_name, <SPAN class=keywordtype>char</SPAN>* __output_buffer,
<A name=l00147></A>00147          size_t* __length, <SPAN class=keywordtype>int</SPAN>* __status);
<A name=l00148></A>00148 <SPAN class=preprocessor>#ifdef __cplusplus</SPAN>
<A name=l00149></A>00149 <SPAN class=preprocessor></SPAN>  }
<A name=l00150></A>00150 } <SPAN class=comment>// namespace __cxxabiv1</SPAN>
<A name=l00151></A>00151 <SPAN class=preprocessor>#endif</SPAN>
<A name=l00152></A>00152 <SPAN class=preprocessor></SPAN>
<A name=l00153></A>00153 <SPAN class=preprocessor>#ifdef __cplusplus</SPAN>
<A name=l00154></A>00154 <SPAN class=preprocessor></SPAN>
<A name=l00155></A>00155 <SPAN class=preprocessor>#include &lt;<A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/typeinfo.html">typeinfo</A>&gt;</SPAN>
<A name=l00156></A>00156 
<A name=l00157></A>00157 <SPAN class=keyword>namespace </SPAN>__cxxabiv1
<A name=l00158></A>00158 {
<A name=l00159></A>00159   <SPAN class=comment>// Type information for int, float etc.</SPAN>
<A name=l00160></A>00160   <SPAN class=keyword>class </SPAN>__fundamental_type_info : <SPAN class=keyword>public</SPAN> std::type_info
<A name=l00161></A>00161   {
<A name=l00162></A>00162   <SPAN class=keyword>public</SPAN>:
<A name=l00163></A>00163     <SPAN class=keyword>explicit</SPAN> 
<A name=l00164></A>00164     __fundamental_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n) : std::type_info(__n) { }
<A name=l00165></A>00165 
<A name=l00166></A>00166     <SPAN class=keyword>virtual</SPAN> 
<A name=l00167></A>00167     ~__fundamental_type_info();
<A name=l00168></A>00168   };
<A name=l00169></A>00169 
<A name=l00170></A>00170   <SPAN class=comment>// Type information for array objects.</SPAN>
<A name=l00171></A>00171   <SPAN class=keyword>class </SPAN>__array_type_info : <SPAN class=keyword>public</SPAN> std::type_info
<A name=l00172></A>00172   {
<A name=l00173></A>00173   <SPAN class=keyword>public</SPAN>:
<A name=l00174></A>00174     <SPAN class=keyword>explicit</SPAN> 
<A name=l00175></A>00175     __array_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n) : std::type_info(__n) { }
<A name=l00176></A>00176 
<A name=l00177></A>00177     <SPAN class=keyword>virtual</SPAN> 
<A name=l00178></A>00178     ~__array_type_info();
<A name=l00179></A>00179   };
<A name=l00180></A>00180 
<A name=l00181></A>00181   <SPAN class=comment>// Type information for functions (both member and non-member).</SPAN>
<A name=l00182></A>00182   <SPAN class=keyword>class </SPAN>__function_type_info : <SPAN class=keyword>public</SPAN> std::type_info
<A name=l00183></A>00183   {
<A name=l00184></A>00184   <SPAN class=keyword>public</SPAN>:
<A name=l00185></A>00185     <SPAN class=keyword>explicit</SPAN> 
<A name=l00186></A>00186     __function_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n) : std::type_info(__n) { }
<A name=l00187></A>00187 
<A name=l00188></A>00188     <SPAN class=keyword>virtual</SPAN> 
<A name=l00189></A>00189     ~__function_type_info();
<A name=l00190></A>00190 
<A name=l00191></A>00191   <SPAN class=keyword>protected</SPAN>:
<A name=l00192></A>00192     <SPAN class=comment>// Implementation defined member function.</SPAN>
<A name=l00193></A>00193     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00194></A>00194     __is_function_p() <SPAN class=keyword>const</SPAN>;
<A name=l00195></A>00195   };
<A name=l00196></A>00196 
<A name=l00197></A>00197   <SPAN class=comment>// Type information for enumerations.</SPAN>
<A name=l00198></A>00198   <SPAN class=keyword>class </SPAN>__enum_type_info : <SPAN class=keyword>public</SPAN> std::type_info
<A name=l00199></A>00199   {
<A name=l00200></A>00200   <SPAN class=keyword>public</SPAN>:
<A name=l00201></A>00201     <SPAN class=keyword>explicit</SPAN> 
<A name=l00202></A>00202     __enum_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n) : std::type_info(__n) { }
<A name=l00203></A>00203 
<A name=l00204></A>00204     <SPAN class=keyword>virtual</SPAN> 
<A name=l00205></A>00205     ~__enum_type_info();
<A name=l00206></A>00206   };
<A name=l00207></A>00207 
<A name=l00208></A>00208   <SPAN class=comment>// Common type information for simple pointers and pointers to member.</SPAN>
<A name=l00209></A>00209   <SPAN class=keyword>class </SPAN>__pbase_type_info : <SPAN class=keyword>public</SPAN> std::type_info
<A name=l00210></A>00210   {
<A name=l00211></A>00211   <SPAN class=keyword>public</SPAN>:
<A name=l00212></A>00212     <SPAN class=keywordtype>unsigned</SPAN> <SPAN class=keywordtype>int</SPAN>        __flags; <SPAN class=comment>// Qualification of the target object.</SPAN>
<A name=l00213></A>00213     <SPAN class=keyword>const</SPAN> <A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/classstd_1_1type__info.html">std::type_info</A>*   __pointee; <SPAN class=comment>// Type of pointed to object.</SPAN>
<A name=l00214></A>00214 
<A name=l00215></A>00215     <SPAN class=keyword>explicit</SPAN> 
<A name=l00216></A>00216     __pbase_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n, <SPAN class=keywordtype>int</SPAN> __quals, 
<A name=l00217></A>00217               <SPAN class=keyword>const</SPAN> <A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/classstd_1_1type__info.html">std::type_info</A>* __type)
<A name=l00218></A>00218     : std::type_info(__n), __flags(__quals), __pointee(__type)
<A name=l00219></A>00219     { }
<A name=l00220></A>00220     
<A name=l00221></A>00221     <SPAN class=keyword>virtual</SPAN> 
<A name=l00222></A>00222     ~__pbase_type_info();
<A name=l00223></A>00223 
<A name=l00224></A>00224     <SPAN class=comment>// Implementation defined type.</SPAN>
<A name=l00225></A>00225     <SPAN class=keyword>enum</SPAN> __masks 
<A name=l00226></A>00226       {
<A name=l00227></A>00227     __const_mask = 0x1,
<A name=l00228></A>00228     __volatile_mask = 0x2,
<A name=l00229></A>00229     __restrict_mask = 0x4,
<A name=l00230></A>00230     __incomplete_mask = 0x8,
<A name=l00231></A>00231     __incomplete_class_mask = 0x10
<A name=l00232></A>00232       };
<A name=l00233></A>00233 
<A name=l00234></A>00234   <SPAN class=keyword>protected</SPAN>:
<A name=l00235></A>00235     __pbase_type_info(<SPAN class=keyword>const</SPAN> __pbase_type_info&amp;);
<A name=l00236></A>00236 
<A name=l00237></A>00237     __pbase_type_info&amp;
<A name=l00238></A>00238     operator=(<SPAN class=keyword>const</SPAN> __pbase_type_info&amp;);
<A name=l00239></A>00239 
<A name=l00240></A>00240     <SPAN class=comment>// Implementation defined member functions.</SPAN>
<A name=l00241></A>00241     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00242></A>00242     __do_catch(<SPAN class=keyword>const</SPAN> <A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/classstd_1_1type__info.html">std::type_info</A>* __thr_type, <SPAN class=keywordtype>void</SPAN>** __thr_obj, 
<A name=l00243></A>00243            <SPAN class=keywordtype>unsigned</SPAN> <SPAN class=keywordtype>int</SPAN> __outer) <SPAN class=keyword>const</SPAN>;
<A name=l00244></A>00244 
<A name=l00245></A>00245     <SPAN class=keyword>inline</SPAN> <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00246></A>00246     __pointer_catch(<SPAN class=keyword>const</SPAN> __pbase_type_info* __thr_type, <SPAN class=keywordtype>void</SPAN>** __thr_obj,
<A name=l00247></A>00247             <SPAN class=keywordtype>unsigned</SPAN> __outer) <SPAN class=keyword>const</SPAN>;
<A name=l00248></A>00248   };
<A name=l00249></A>00249 
<A name=l00250></A>00250   <SPAN class=comment>// Type information for simple pointers.</SPAN>
<A name=l00251></A>00251   <SPAN class=keyword>class </SPAN>__pointer_type_info : <SPAN class=keyword>public</SPAN> __pbase_type_info
<A name=l00252></A>00252   {
<A name=l00253></A>00253   <SPAN class=keyword>public</SPAN>:
<A name=l00254></A>00254     <SPAN class=keyword>explicit</SPAN> 
<A name=l00255></A>00255     __pointer_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n, <SPAN class=keywordtype>int</SPAN> __quals, 
<A name=l00256></A>00256             <SPAN class=keyword>const</SPAN> <A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/classstd_1_1type__info.html">std::type_info</A>* __type)
<A name=l00257></A>00257     : __pbase_type_info (__n, __quals, __type) { }
<A name=l00258></A>00258 
<A name=l00259></A>00259 
<A name=l00260></A>00260     <SPAN class=keyword>virtual</SPAN> 
<A name=l00261></A>00261     ~__pointer_type_info();
<A name=l00262></A>00262 
<A name=l00263></A>00263   <SPAN class=keyword>protected</SPAN>:
<A name=l00264></A>00264     <SPAN class=comment>// Implementation defined member functions.</SPAN>
<A name=l00265></A>00265     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00266></A>00266     __is_pointer_p() <SPAN class=keyword>const</SPAN>;
<A name=l00267></A>00267 
<A name=l00268></A>00268     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00269></A>00269     __pointer_catch(<SPAN class=keyword>const</SPAN> __pbase_type_info* __thr_type, <SPAN class=keywordtype>void</SPAN>** __thr_obj, 
<A name=l00270></A>00270             <SPAN class=keywordtype>unsigned</SPAN> __outer) <SPAN class=keyword>const</SPAN>;
<A name=l00271></A>00271   };
<A name=l00272></A>00272 
<A name=l00273></A>00273   <SPAN class=keyword>class </SPAN>__class_type_info;
<A name=l00274></A>00274 
<A name=l00275></A>00275   <SPAN class=comment>// Type information for a pointer to member variable.</SPAN>
<A name=l00276></A>00276   <SPAN class=keyword>class </SPAN>__pointer_to_member_type_info : <SPAN class=keyword>public</SPAN> __pbase_type_info
<A name=l00277></A>00277   {
<A name=l00278></A>00278   <SPAN class=keyword>public</SPAN>:
<A name=l00279></A>00279     __class_type_info* __context;   <SPAN class=comment>// Class of the member.</SPAN>
<A name=l00280></A>00280 
<A name=l00281></A>00281     <SPAN class=keyword>explicit</SPAN> 
<A name=l00282></A>00282     __pointer_to_member_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n, <SPAN class=keywordtype>int</SPAN> __quals,
<A name=l00283></A>00283                   <SPAN class=keyword>const</SPAN> <A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/classstd_1_1type__info.html">std::type_info</A>* __type, 
<A name=l00284></A>00284                   __class_type_info* __klass)
<A name=l00285></A>00285     : __pbase_type_info(__n, __quals, __type), __context(__klass) { }
<A name=l00286></A>00286 
<A name=l00287></A>00287     <SPAN class=keyword>virtual</SPAN> 
<A name=l00288></A>00288     ~__pointer_to_member_type_info();
<A name=l00289></A>00289 
<A name=l00290></A>00290   <SPAN class=keyword>protected</SPAN>:
<A name=l00291></A>00291     __pointer_to_member_type_info(<SPAN class=keyword>const</SPAN> __pointer_to_member_type_info&amp;);
<A name=l00292></A>00292 
<A name=l00293></A>00293     __pointer_to_member_type_info&amp;
<A name=l00294></A>00294     operator=(<SPAN class=keyword>const</SPAN> __pointer_to_member_type_info&amp;);
<A name=l00295></A>00295 
<A name=l00296></A>00296     <SPAN class=comment>// Implementation defined member function.</SPAN>
<A name=l00297></A>00297     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00298></A>00298     __pointer_catch(<SPAN class=keyword>const</SPAN> __pbase_type_info* __thr_type, <SPAN class=keywordtype>void</SPAN>** __thr_obj,
<A name=l00299></A>00299             <SPAN class=keywordtype>unsigned</SPAN> __outer) <SPAN class=keyword>const</SPAN>;
<A name=l00300></A>00300   };
<A name=l00301></A>00301 
<A name=l00302></A>00302   <SPAN class=comment>// Helper class for __vmi_class_type.</SPAN>
<A name=l00303></A>00303   <SPAN class=keyword>class </SPAN>__base_class_type_info
<A name=l00304></A>00304   {
<A name=l00305></A>00305   <SPAN class=keyword>public</SPAN>:
<A name=l00306></A>00306     <SPAN class=keyword>const</SPAN> __class_type_info*    __base_type;  <SPAN class=comment>// Base class type.</SPAN>
<A name=l00307></A>00307     <SPAN class=keywordtype>long</SPAN>            __offset_flags;  <SPAN class=comment>// Offset and info.</SPAN>
<A name=l00308></A>00308 
<A name=l00309></A>00309     <SPAN class=keyword>enum</SPAN> __offset_flags_masks 
<A name=l00310></A>00310       {
<A name=l00311></A>00311     __virtual_mask = 0x1,
<A name=l00312></A>00312     __public_mask = 0x2,
<A name=l00313></A>00313     __hwm_bit = 2,
<A name=l00314></A>00314     __offset_shift = 8          <SPAN class=comment>// Bits to shift offset.</SPAN>
<A name=l00315></A>00315       };
<A name=l00316></A>00316   
<A name=l00317></A>00317     <SPAN class=comment>// Implementation defined member functions.</SPAN>
<A name=l00318></A>00318     <SPAN class=keywordtype>bool</SPAN> 
<A name=l00319></A>00319     __is_virtual_p()<SPAN class=keyword> const</SPAN>
<A name=l00320></A>00320 <SPAN class=keyword>    </SPAN>{ <SPAN class=keywordflow>return</SPAN> __offset_flags &amp; __virtual_mask; }
<A name=l00321></A>00321 
<A name=l00322></A>00322     <SPAN class=keywordtype>bool</SPAN> 
<A name=l00323></A>00323     __is_public_p()<SPAN class=keyword> const</SPAN>
<A name=l00324></A>00324 <SPAN class=keyword>    </SPAN>{ <SPAN class=keywordflow>return</SPAN> __offset_flags &amp; __public_mask; }
<A name=l00325></A>00325 
<A name=l00326></A>00326     ptrdiff_t 
<A name=l00327></A>00327     __offset()<SPAN class=keyword> const</SPAN>
<A name=l00328></A>00328 <SPAN class=keyword>    </SPAN>{ 
<A name=l00329></A>00329       <SPAN class=comment>// This shift, being of a signed type, is implementation</SPAN>
<A name=l00330></A>00330       <SPAN class=comment>// defined. GCC implements such shifts as arithmetic, which is</SPAN>
<A name=l00331></A>00331       <SPAN class=comment>// what we want.</SPAN>
<A name=l00332></A>00332       <SPAN class=keywordflow>return</SPAN> static_cast&lt;ptrdiff_t&gt;(__offset_flags) &gt;&gt; __offset_shift;
<A name=l00333></A>00333     }
<A name=l00334></A>00334   };
<A name=l00335></A>00335 
<A name=l00336></A>00336   <SPAN class=comment>// Type information for a class.</SPAN>
<A name=l00337></A>00337   <SPAN class=keyword>class </SPAN>__class_type_info : <SPAN class=keyword>public</SPAN> std::type_info
<A name=l00338></A>00338   {
<A name=l00339></A>00339   <SPAN class=keyword>public</SPAN>:
<A name=l00340></A>00340     <SPAN class=keyword>explicit</SPAN> 
<A name=l00341></A>00341     __class_type_info (<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN> *__n) : type_info(__n) { }
<A name=l00342></A>00342 
<A name=l00343></A>00343     <SPAN class=keyword>virtual</SPAN> 
<A name=l00344></A>00344     ~__class_type_info ();
<A name=l00345></A>00345 
<A name=l00346></A>00346     <SPAN class=comment>// Implementation defined types.</SPAN>
<A name=l00347></A>00347     <SPAN class=comment>// The type sub_kind tells us about how a base object is contained</SPAN>
<A name=l00348></A>00348     <SPAN class=comment>// within a derived object. We often do this lazily, hence the</SPAN>
<A name=l00349></A>00349     <SPAN class=comment>// UNKNOWN value. At other times we may use NOT_CONTAINED to mean</SPAN>
<A name=l00350></A>00350     <SPAN class=comment>// not publicly contained.</SPAN>
<A name=l00351></A>00351     <SPAN class=keyword>enum</SPAN> __sub_kind
<A name=l00352></A>00352       {
<A name=l00353></A>00353     <SPAN class=comment>// We have no idea.</SPAN>
<A name=l00354></A>00354     __unknown = 0, 
<A name=l00355></A>00355 
<A name=l00356></A>00356     <SPAN class=comment>// Not contained within us (in some circumstances this might</SPAN>
<A name=l00357></A>00357     <SPAN class=comment>// mean not contained publicly)</SPAN>
<A name=l00358></A>00358     __not_contained, 
<A name=l00359></A>00359 
<A name=l00360></A>00360     <SPAN class=comment>// Contained ambiguously.</SPAN>
<A name=l00361></A>00361     __contained_ambig, 
<A name=l00362></A>00362     
<A name=l00363></A>00363     <SPAN class=comment>// Via a virtual path.</SPAN>
<A name=l00364></A>00364     __contained_virtual_mask = __base_class_type_info::__virtual_mask, 
<A name=l00365></A>00365 
<A name=l00366></A>00366     <SPAN class=comment>// Via a public path.</SPAN>
<A name=l00367></A>00367     __contained_public_mask = __base_class_type_info::__public_mask,   
<A name=l00368></A>00368 
<A name=l00369></A>00369     <SPAN class=comment>// Contained within us.</SPAN>
<A name=l00370></A>00370     __contained_mask = 1 &lt;&lt; __base_class_type_info::__hwm_bit,
<A name=l00371></A>00371     
<A name=l00372></A>00372     __contained_private = __contained_mask,
<A name=l00373></A>00373     __contained_public = __contained_mask | __contained_public_mask
<A name=l00374></A>00374       };
<A name=l00375></A>00375 
<A name=l00376></A>00376     <SPAN class=keyword>struct </SPAN>__upcast_result;
<A name=l00377></A>00377     <SPAN class=keyword>struct </SPAN>__dyncast_result;
<A name=l00378></A>00378 
<A name=l00379></A>00379   <SPAN class=keyword>protected</SPAN>:
<A name=l00380></A>00380     <SPAN class=comment>// Implementation defined member functions.</SPAN>
<A name=l00381></A>00381     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00382></A>00382     __do_upcast(<SPAN class=keyword>const</SPAN> __class_type_info* __dst_type, <SPAN class=keywordtype>void</SPAN>**__obj_ptr) <SPAN class=keyword>const</SPAN>;
<A name=l00383></A>00383 
<A name=l00384></A>00384     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00385></A>00385     __do_catch(<SPAN class=keyword>const</SPAN> type_info* __thr_type, <SPAN class=keywordtype>void</SPAN>** __thr_obj, 
<A name=l00386></A>00386            <SPAN class=keywordtype>unsigned</SPAN> __outer) <SPAN class=keyword>const</SPAN>;
<A name=l00387></A>00387 
<A name=l00388></A>00388   <SPAN class=keyword>public</SPAN>:
<A name=l00389></A>00389     <SPAN class=comment>// Helper for upcast. See if DST is us, or one of our bases. </SPAN>
<A name=l00390></A>00390     <SPAN class=comment>// Return false if not found, true if found. </SPAN>
<A name=l00391></A>00391     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00392></A>00392     __do_upcast(<SPAN class=keyword>const</SPAN> __class_type_info* __dst, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj,
<A name=l00393></A>00393         __upcast_result&amp; __restrict __result) <SPAN class=keyword>const</SPAN>;
<A name=l00394></A>00394 
<A name=l00395></A>00395     <SPAN class=comment>// Indicate whether SRC_PTR of type SRC_TYPE is contained publicly</SPAN>
<A name=l00396></A>00396     <SPAN class=comment>// within OBJ_PTR. OBJ_PTR points to a base object of our type,</SPAN>
<A name=l00397></A>00397     <SPAN class=comment>// which is the destination type. SRC2DST indicates how SRC</SPAN>
<A name=l00398></A>00398     <SPAN class=comment>// objects might be contained within this type.  If SRC_PTR is one</SPAN>
<A name=l00399></A>00399     <SPAN class=comment>// of our SRC_TYPE bases, indicate the virtuality. Returns</SPAN>
<A name=l00400></A>00400     <SPAN class=comment>// not_contained for non containment or private containment.</SPAN>
<A name=l00401></A>00401     <SPAN class=keyword>inline</SPAN> __sub_kind 
<A name=l00402></A>00402     __find_public_src(ptrdiff_t __src2dst, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj_ptr,
<A name=l00403></A>00403               <SPAN class=keyword>const</SPAN> __class_type_info* __src_type, 
<A name=l00404></A>00404               <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __src_ptr) <SPAN class=keyword>const</SPAN>;
<A name=l00405></A>00405 
<A name=l00406></A>00406     <SPAN class=comment>// Helper for dynamic cast. ACCESS_PATH gives the access from the</SPAN>
<A name=l00407></A>00407     <SPAN class=comment>// most derived object to this base. DST_TYPE indicates the</SPAN>
<A name=l00408></A>00408     <SPAN class=comment>// desired type we want. OBJ_PTR points to a base of our type</SPAN>
<A name=l00409></A>00409     <SPAN class=comment>// within the complete object. SRC_TYPE indicates the static type</SPAN>
<A name=l00410></A>00410     <SPAN class=comment>// started from and SRC_PTR points to that base within the most</SPAN>
<A name=l00411></A>00411     <SPAN class=comment>// derived object. Fill in RESULT with what we find. Return true</SPAN>
<A name=l00412></A>00412     <SPAN class=comment>// if we have located an ambiguous match.</SPAN>
<A name=l00413></A>00413     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00414></A>00414     __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
<A name=l00415></A>00415          <SPAN class=keyword>const</SPAN> __class_type_info* __dst_type, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj_ptr, 
<A name=l00416></A>00416          <SPAN class=keyword>const</SPAN> __class_type_info* __src_type, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __src_ptr, 
<A name=l00417></A>00417          __dyncast_result&amp; __result) <SPAN class=keyword>const</SPAN>;
<A name=l00418></A>00418     
<A name=l00419></A>00419     <SPAN class=comment>// Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE</SPAN>
<A name=l00420></A>00420     <SPAN class=comment>// bases are inherited by the type started from -- which is not</SPAN>
<A name=l00421></A>00421     <SPAN class=comment>// necessarily the current type. The current type will be a base</SPAN>
<A name=l00422></A>00422     <SPAN class=comment>// of the destination type.  OBJ_PTR points to the current base.</SPAN>
<A name=l00423></A>00423     <SPAN class=keyword>virtual</SPAN> __sub_kind 
<A name=l00424></A>00424     __do_find_public_src(ptrdiff_t __src2dst, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj_ptr,
<A name=l00425></A>00425              <SPAN class=keyword>const</SPAN> __class_type_info* __src_type,
<A name=l00426></A>00426              <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __src_ptr) <SPAN class=keyword>const</SPAN>;
<A name=l00427></A>00427   };
<A name=l00428></A>00428 
<A name=l00429></A>00429   <SPAN class=comment>// Type information for a class with a single non-virtual base.</SPAN>
<A name=l00430></A>00430   <SPAN class=keyword>class </SPAN>__si_class_type_info : <SPAN class=keyword>public</SPAN> __class_type_info
<A name=l00431></A>00431   {
<A name=l00432></A>00432   <SPAN class=keyword>public</SPAN>:
<A name=l00433></A>00433     <SPAN class=keyword>const</SPAN> __class_type_info* __base_type;
<A name=l00434></A>00434 
<A name=l00435></A>00435     <SPAN class=keyword>explicit</SPAN> 
<A name=l00436></A>00436     __si_class_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN> *__n, <SPAN class=keyword>const</SPAN> __class_type_info *__base)
<A name=l00437></A>00437     : __class_type_info(__n), __base_type(__base) { }
<A name=l00438></A>00438 
<A name=l00439></A>00439     <SPAN class=keyword>virtual</SPAN> 
<A name=l00440></A>00440     ~__si_class_type_info();
<A name=l00441></A>00441 
<A name=l00442></A>00442   <SPAN class=keyword>protected</SPAN>:
<A name=l00443></A>00443     __si_class_type_info(<SPAN class=keyword>const</SPAN> __si_class_type_info&amp;);
<A name=l00444></A>00444 
<A name=l00445></A>00445     __si_class_type_info&amp;
<A name=l00446></A>00446     operator=(<SPAN class=keyword>const</SPAN> __si_class_type_info&amp;);
<A name=l00447></A>00447 
<A name=l00448></A>00448     <SPAN class=comment>// Implementation defined member functions.</SPAN>
<A name=l00449></A>00449     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00450></A>00450     __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
<A name=l00451></A>00451          <SPAN class=keyword>const</SPAN> __class_type_info* __dst_type, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj_ptr,
<A name=l00452></A>00452          <SPAN class=keyword>const</SPAN> __class_type_info* __src_type, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __src_ptr,
<A name=l00453></A>00453          __dyncast_result&amp; __result) <SPAN class=keyword>const</SPAN>;
<A name=l00454></A>00454 
<A name=l00455></A>00455     <SPAN class=keyword>virtual</SPAN> __sub_kind 
<A name=l00456></A>00456     __do_find_public_src(ptrdiff_t __src2dst, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj_ptr,
<A name=l00457></A>00457              <SPAN class=keyword>const</SPAN> __class_type_info* __src_type,
<A name=l00458></A>00458              <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __sub_ptr) <SPAN class=keyword>const</SPAN>;
<A name=l00459></A>00459 
<A name=l00460></A>00460     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00461></A>00461     __do_upcast(<SPAN class=keyword>const</SPAN> __class_type_info*__dst, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>*__obj,
<A name=l00462></A>00462         __upcast_result&amp; __restrict __result) <SPAN class=keyword>const</SPAN>;
<A name=l00463></A>00463   };
<A name=l00464></A>00464 
<A name=l00465></A>00465   <SPAN class=comment>// Type information for a class with multiple and/or virtual bases.</SPAN>
<A name=l00466></A>00466   <SPAN class=keyword>class </SPAN>__vmi_class_type_info : <SPAN class=keyword>public</SPAN> __class_type_info 
<A name=l00467></A>00467   {
<A name=l00468></A>00468   <SPAN class=keyword>public</SPAN>:
<A name=l00469></A>00469     <SPAN class=keywordtype>unsigned</SPAN> <SPAN class=keywordtype>int</SPAN>        __flags;  <SPAN class=comment>// Details about the class hierarchy.</SPAN>
<A name=l00470></A>00470     <SPAN class=keywordtype>unsigned</SPAN> <SPAN class=keywordtype>int</SPAN>        __base_count;  <SPAN class=comment>// Dumber of direct bases.</SPAN>
<A name=l00471></A>00471 
<A name=l00472></A>00472     <SPAN class=comment>// The array of bases uses the trailing array struct hack so this</SPAN>
<A name=l00473></A>00473     <SPAN class=comment>// class is not constructable with a normal constructor. It is</SPAN>
<A name=l00474></A>00474     <SPAN class=comment>// internally generated by the compiler.</SPAN>
<A name=l00475></A>00475     __base_class_type_info  __base_info[1];  <SPAN class=comment>// Array of bases.</SPAN>
<A name=l00476></A>00476 
<A name=l00477></A>00477     <SPAN class=keyword>explicit</SPAN> 
<A name=l00478></A>00478     __vmi_class_type_info(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>char</SPAN>* __n, <SPAN class=keywordtype>int</SPAN> ___flags)
<A name=l00479></A>00479     : __class_type_info(__n), __flags(___flags), __base_count(0) { }
<A name=l00480></A>00480 
<A name=l00481></A>00481     <SPAN class=keyword>virtual</SPAN> 
<A name=l00482></A>00482     ~__vmi_class_type_info();
<A name=l00483></A>00483 
<A name=l00484></A>00484     <SPAN class=comment>// Implementation defined types.</SPAN>
<A name=l00485></A>00485     <SPAN class=keyword>enum</SPAN> __flags_masks 
<A name=l00486></A>00486       {
<A name=l00487></A>00487     __non_diamond_repeat_mask = 0x1, <SPAN class=comment>// Distinct instance of repeated base.</SPAN>
<A name=l00488></A>00488     __diamond_shaped_mask = 0x2, <SPAN class=comment>// Diamond shaped multiple inheritance.</SPAN>
<A name=l00489></A>00489     __flags_unknown_mask = 0x10
<A name=l00490></A>00490       };
<A name=l00491></A>00491 
<A name=l00492></A>00492   <SPAN class=keyword>protected</SPAN>:
<A name=l00493></A>00493     <SPAN class=comment>// Implementation defined member functions.</SPAN>
<A name=l00494></A>00494     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00495></A>00495     __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
<A name=l00496></A>00496          <SPAN class=keyword>const</SPAN> __class_type_info* __dst_type, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj_ptr,
<A name=l00497></A>00497          <SPAN class=keyword>const</SPAN> __class_type_info* __src_type, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __src_ptr,
<A name=l00498></A>00498          __dyncast_result&amp; __result) <SPAN class=keyword>const</SPAN>;
<A name=l00499></A>00499 
<A name=l00500></A>00500     <SPAN class=keyword>virtual</SPAN> __sub_kind 
<A name=l00501></A>00501     __do_find_public_src(ptrdiff_t __src2dst, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj_ptr, 
<A name=l00502></A>00502              <SPAN class=keyword>const</SPAN> __class_type_info* __src_type,
<A name=l00503></A>00503              <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __src_ptr) <SPAN class=keyword>const</SPAN>;
<A name=l00504></A>00504     
<A name=l00505></A>00505     <SPAN class=keyword>virtual</SPAN> <SPAN class=keywordtype>bool</SPAN> 
<A name=l00506></A>00506     __do_upcast(<SPAN class=keyword>const</SPAN> __class_type_info* __dst, <SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __obj,
<A name=l00507></A>00507         __upcast_result&amp; __restrict __result) <SPAN class=keyword>const</SPAN>;
<A name=l00508></A>00508   };
<A name=l00509></A>00509 
<A name=l00510></A>00510   <SPAN class=comment>// Dynamic cast runtime.</SPAN>
<A name=l00511></A>00511   <SPAN class=comment>// src2dst has the following possible values</SPAN>
<A name=l00512></A>00512   <SPAN class=comment>//  &gt;-1: src_type is a unique public non-virtual base of dst_type</SPAN>
<A name=l00513></A>00513   <SPAN class=comment>//       dst_ptr + src2dst == src_ptr</SPAN>
<A name=l00514></A>00514   <SPAN class=comment>//   -1: unspecified relationship</SPAN>
<A name=l00515></A>00515   <SPAN class=comment>//   -2: src_type is not a public base of dst_type</SPAN>
<A name=l00516></A>00516   <SPAN class=comment>//   -3: src_type is a multiple public non-virtual base of dst_type</SPAN>
<A name=l00517></A>00517   <SPAN class=keyword>extern</SPAN> <SPAN class=stringliteral>"C"</SPAN> <SPAN class=keywordtype>void</SPAN>*
<A name=l00518></A>00518   __dynamic_cast(<SPAN class=keyword>const</SPAN> <SPAN class=keywordtype>void</SPAN>* __src_ptr, <SPAN class=comment>// Starting object.</SPAN>
<A name=l00519></A>00519          <SPAN class=keyword>const</SPAN> __class_type_info* __src_type, <SPAN class=comment>// Static type of object.</SPAN>
<A name=l00520></A>00520          <SPAN class=keyword>const</SPAN> __class_type_info* __dst_type, <SPAN class=comment>// Desired target type.</SPAN>
<A name=l00521></A>00521          ptrdiff_t __src2dst); <SPAN class=comment>// How src and dst are related.</SPAN>
<A name=l00522></A>00522 
<A name=l00523></A>00523 
<A name=l00524></A>00524   <SPAN class=comment>// Returns the type_info for the currently handled exception [15.3/8], or</SPAN>
<A name=l00525></A>00525   <SPAN class=comment>// null if there is none.</SPAN>
<A name=l00526></A>00526   <SPAN class=keyword>extern</SPAN> <SPAN class=stringliteral>"C"</SPAN> <A class=code href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/classstd_1_1type__info.html">std::type_info</A>*
<A name=l00527></A>00527   __cxa_current_exception_type();
<A name=l00528></A>00528 } <SPAN class=comment>// namespace __cxxabiv1</SPAN>
<A name=l00529></A>00529 
<A name=l00530></A>00530 <SPAN class=comment>// User programs should use the alias `abi'. </SPAN>
<A name=l00531></A>00531 <SPAN class=keyword>namespace </SPAN>abi = __cxxabiv1;
<A name=l00532></A>00532 
<A name=l00533></A>00533 <SPAN class=preprocessor>#endif // __cplusplus</SPAN>
<A name=l00534></A>00534 <SPAN class=preprocessor></SPAN>
<A name=l00535></A>00535 <SPAN class=preprocessor>#pragma GCC visibility pop</SPAN>
<A name=l00536></A>00536 <SPAN class=preprocessor></SPAN>
<A name=l00537></A>00537 <SPAN class=preprocessor>#endif // __CXXABI_H </SPAN>
</PRE></DIV>
<HR SIZE=1>

<ADDRESS style="align: right"><SMALL>Generated on Fri Oct 7 09:42:55 2005 for 
libstdc++ by&nbsp; <A href="http://www.doxygen.org/index.html"><IMG alt=doxygen 
src="libstdc++ - cxxabi-Dateien/doxygen.png" align=middle border=0></A> 1.4.4 
</SMALL></ADDRESS></BODY></HTML>
