<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0085)http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html -->
<HTML><HEAD><TITLE>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 10)</TITLE><!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META http-equiv=pragma content=no-cache>
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#000000 link=#008000 bgColor=#ffffff topMargin=10 
stylesrc="../toc.html">
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="100%" colSpan=3>
      <P align=right><A name=top></A><FONT face=Arial size=1>The Art 
      of<BR></FONT><FONT face="Arial Black" size=1>ASSEMBLY LANGUAGE 
      PROGRAMMING</FONT></P></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1><A name=HEADING10></A></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-9.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 10)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-9.html">Chapter 
      Thirteen</A> (Part 9)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-11.html">Chapter 
      Thirteen</A> (Part 11)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-11.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 10)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD noWrap width="100%" bgColor=#ffffff colSpan=2 height=10><A 
      name=HEADING10-1></A></TD></TR>
  <TR>
    <TD width="100%" bgColor=#f0f0f0 colSpan=2><FONT face=Arial 
      size=4><STRONG>CHAPTER THIRTEEN:<BR>MS-DOS, PC-BIOS AND FILE I/O (Part 
      10)</STRONG></FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 height=10></TD></TR>
  <TR>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-1"><B>13.4 
      </B>- UCR Standard Library File I/O Routines</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-9"><B>13.4.1 
      </B>- Fopen</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-25"><B>13.4.2 
      </B>- Fcreate</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-37"><B>13.4.3 
      </B>- Fclose</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-47"><B>13.4.4 
      </B>- Fflush</A> </FONT></TD>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-56"><B>13.4.5 
      </B>- Fgetc</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-68"><B>13.4.6 
      </B>- Fread</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-83"><B>13.4.7 
      </B>- Fputc</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-94"><B>13.4.8 
      </B>- Fwrite</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#HEADING10-108"><B>13.4.9 
      </B>- Redirecting I/O Through the StdLib File I/O Routines</A> 
  </FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 height=20><FONT face=Arial 
    size=2></FONT></TD></TR>
  <TR>
    <TD width="100%" colSpan=2><FONT face=Arial size=2></FONT><STRONG><FONT 
      face=Arial size=3>13.4 UCR Standard Library File I/O 
      Routines</FONT></STRONG><FONT face=Arial size=2></FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" bgColor=#000000 colSpan=2 height=1><FONT 
      face=Arial size=2></FONT></TD></TR></TBODY></TABLE></CENTER></DIV>
<P><FONT face=Arial size=2>Although MS-DOS' file I/O facilities are not too bad, 
the UCR Standard Library provides a file I/O package which makes blocked 
sequential I/O as easy as character at a time file I/O. Furthermore, with a tiny 
amount of effort, you can use all the StdLib routines like <CODE>printf, print, 
puti, puth, putc, getc, gets,</CODE> etc., when performing file I/O. This 
greatly simplifies text file operations in assembly language.</FONT></P>
<P><FONT face=Arial size=2>Note that record oriented, or binary I/O, is probably 
best left to pure DOS. any time you want to do random access within a file. The 
Standard Library routines really only support sequential text I/O. Nevertheless, 
this is the most common form of file I/O around, so the Standard Library 
routines are quite useful indeed.</FONT></P>
<P><FONT face=Arial size=2>The UCR Standard Library provides eight file I/O 
routines: <CODE>fopen</CODE>, <CODE>fcreate</CODE>, <CODE>fclose</CODE>, 
<CODE>fgetc</CODE>, <CODE>fread</CODE>, <CODE>fputc</CODE>, and 
<CODE>fwrite</CODE>. <CODE>Fgetc </CODE>and <CODE>fputc </CODE>perform character 
at a time I/O, <CODE>fread </CODE>and <CODE>fwrite </CODE>let you read and write 
blocks of data, the other four functions perform the obvious DOS 
operations.</FONT></P>
<P><FONT face=Arial size=2>The UCR Standard Library uses a special file variable 
to keep track of file operations. There is a special record type, FileVar, 
declared in stdlib.a<A 
href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#FOOTNOTE-8">[8]</A>. 
When using the StdLib file I/O routines you must create a variable of type 
<CODE>FileVar</CODE> for every file you need open at the same time. This is very 
easy, just use a definition of the form:</FONT></P><PRE><FONT face="Courier New" size=2>	MyFileVar       FileVar {}</FONT></PRE>
<P><FONT face=Arial size=2>Please note that a Standard Library file variable is 
not the same thing as a DOS file handle. It is a structure which contains the 
DOS file handle, a buffer (for blocked I/O), and various index and status 
variables. The internal structure of this type is of no interest (remember data 
encapsulation!) except to the implementor of the file routines. You will pass 
the address of this file variable to the various Standard Library file I/O 
routines.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-9></A>13.4.1 
Fopen</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                ax-     File open mode
                 0- File opened for reading 
                 1- File opened for writing
                dx:si-  Points at a zero terminated string containing 
                        the filename.
                es:di-  Points at a StdLib file variable.

Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</FONT></PRE><CODE>
<P><FONT face=Arial size=2>Fopen </CODE>opens a sequential text file for reading 
or writing. Unlike DOS, you cannot open a file for reading and writing. 
Furthermore, this is a sequential text file which does not support random 
access. Note that the file must exist or <CODE>fopen </CODE>will return an 
error. This is even true when you open the file for writing. </FONT></P>
<P><FONT face=Arial size=2>Note that if you open a file for writing and that 
file already exists, any data written to the file will overwrite the existing 
data. When you close the file, any data appearing in the file after the data you 
wrote will still be there. If you want to erase the existing file before writing 
data to it, use the <CODE>fcreate </CODE>function.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-25></A>13.4.2 
Fcreate</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                dx:si-  Points at a zero terminated string containing 
                        the filename.
                es:di-  Points at a StdLib file variable.

Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</FONT></PRE><CODE>
<P><FONT face=Arial size=2>Fcreate</CODE> creates a new file and opens it for 
writing. If the file already exists, <CODE>fcreate</CODE> deletes the existing 
file and creates a new one. It initializes the file variable for output but is 
otherwise identical to the <CODE>fopen </CODE>call.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-37></A>13.4.3 
Fclose</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                es:di-  Points at a StdLib file variable.
Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</FONT></PRE><CODE>
<P><FONT face=Arial size=2>Fclose </CODE>closes a file and updates any internal 
housekeeping information. It is very important that you close all files opened 
with <CODE>fopen </CODE>or <CODE>fcreate </CODE>using this call. When making DOS 
file calls, if you forget to close a file DOS will automatically do that for you 
when your program terminates. However, the StdLib routines cache up data in 
internal buffers. the fclose call automatically flushes these buffers to disk. 
If you exit your program without calling <CODE>fclose</CODE>, you may lose some 
data written to the file but not yet transferred from the internal buffer to the 
disk.</FONT></P>
<P><FONT face=Arial size=2>If you are in an environment where it is possible for 
someone to abort the program without giving you a chance to close the file, you 
should call the fflush routines (see the next section) on a regular basis to 
avoid losing too much data.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-47></A>13.4.4 
Fflush</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                es:di-  Points at a StdLib file variable.
Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</FONT></PRE>
<P><FONT face=Arial size=2>This routine immediately writes any data in the 
internal file buffer to disk. Note that you should only use this routine in 
conjunction with files opened for writing (or opened by <CODE>fcreate</CODE>). 
If you write data to a file and then need to leave the file open, but inactive, 
for some time period, you should perform a flush operation in case the program 
terminates abnormally.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-56></A>13.4.5 
Fgetc</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                es:di-  Points at a StdLib file variable.
Exit parameters:        
                If the carry flag is clear, 
                 al contains the character read from the file.
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function). ax will contain zero if you attempt to read beyond the end of file.</FONT></PRE><CODE>
<P><FONT face=Arial size=2>Fgetc</CODE> reads a single character from the file 
and returns this character in the <CODE>al </CODE>register. Unlike calls to DOS, 
single character I/O using <CODE>fgetc </CODE>is relatively fast since the 
StdLib routines use blocked I/O. Of course, multiple calls to <CODE>fgetc</CODE> 
will never be faster than a call to <CODE>fread</CODE> (see the next section), 
but the performance is not too bad.</FONT></P>
<P><FONT face=Arial size=2><CODE>Fgetc</CODE> is very flexible. As you will see 
in a little bit, you may redirect the StdLib input routines to read their data 
from a file using <CODE>fgetc</CODE>. This lets you use the higher level 
routines like <CODE>gets</CODE> and <CODE>getsm</CODE> when reading data from a 
file.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-68></A>13.4.6 
Fread</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                es:di-  Points at a StdLib file variable.
                dx:si-  Points at an input data buffer.
                cx-     Contains a byte count.
Exit parameters:        
                If the carry flag is clear, 
                 ax contains the actual number of bytes 
                 read from the file.
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</FONT></PRE>
<P><FONT face=Arial size=2><CODE>Fread</CODE> is very similar to the DOS 
<CODE>read</CODE> command. It lets you read a block of bytes, rather than just 
one byte, from a file. Note that if all you are doing is reading a block of 
bytes from a file, the DOS call is slightly more efficient than 
<CODE>fread</CODE>. However, if you have a mixture of single byte reads and 
multi-byte reads, the combination of <CODE>fread</CODE> and <CODE>fgetc</CODE> 
work very well.</FONT></P>
<P><FONT face=Arial size=2>As with the DOS read operation, if the byte count 
returned in <CODE>ax </CODE>does not match the value passed in the <CODE>cx 
</CODE>register, then you've read the remaining bytes in the file. When this 
occurs, the next call to <CODE>fread</CODE> or <CODE>fgetc</CODE> will return an 
EOF error (carry will be set and <CODE>ax </CODE>will contain zero). Note that 
<CODE>fread</CODE> does not return EOF unless there were zero bytes read from 
the file.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-83></A>13.4.7 
Fputc</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                es:di-  Points at a StdLib file variable.
                al-     Contains the character to write to the file.

Exit parameters:        
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</FONT></PRE>
<P><FONT face=Arial size=2><CODE>Fputc</CODE> writes a single character (in 
<CODE>al</CODE>) to the file specified by the file variable whose address is in 
<CODE>es:di</CODE>. This call simply adds the character in <CODE>al </CODE>to an 
internal buffer (part of the file variable) until the buffer is full. Whenever 
the buffer is filled or you call <CODE>fflush</CODE> (or close the file with 
<CODE>fclose</CODE>), the file I/O routines write the data to disk.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-94></A>13.4.8 
Fwrite</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Entry parameters:       
                es:di-  Points at a StdLib file variable.
                dx:si-  Points at an output data buffer.
                cx-     Contains a byte count.
Exit parameters:        
                If the carry flag is clear, 
                 ax contains the actual number of bytes 
                 written to the file.
                If the carry is set, 
                 ax contains the returned DOS error code 
                 (see DOS open function).</FONT></PRE>
<P><FONT face=Arial size=2>Like <CODE>fread</CODE>, <CODE>fwrite</CODE> works on 
blocks of bytes. It lets you write a block of bytes to a file opened for writing 
with fopen or fcreate.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING10-108></A>13.4.9 Redirecting 
I/O Through the StdLib File I/O Routines</FONT></STRONG></P>
<P><FONT face=Arial size=2>The Standard Library provides very few file I/O 
routines. <CODE>Fputc</CODE> and <CODE>fwrite</CODE> are the only two output 
routines, for example. The "C" programming language standard library (on which 
the UCR Standard Library is based) provides many routines like <CODE>fprintf, 
fputs, fscanf, </CODE>etc. None of these are necessary in the UCR Standard 
Library because the UCR library provides an I/O redirection mechanism that lets 
you reuse all existing I/O routines to perform file I/O.</FONT></P>
<P><FONT face=Arial size=2>The UCR Standard Library <CODE>putc</CODE> routine 
consists of a single <CODE>jmp </CODE>instruction. This instruction transfers 
control to some actual output routine via an indirect address internal to the 
putc code. Normally, this pointer variable points at a piece of code which 
writes the character in the <CODE>al </CODE>register to the DOS standard output 
device. However, the Standard Library also provides four routines which let you 
manipulate this indirect pointer. By changing this pointer you can redirect the 
output from its current routine to a routine of your choosing. All Standard 
Library output routines (e.g., <CODE>printf, puti, puth, puts</CODE>) call 
<CODE>putc</CODE> to output individual characters. Therefore, redirecting the 
<CODE>putc</CODE> routine affects all the output routines. </FONT></P>
<P><FONT face=Arial size=2>Likewise, the <CODE>getc</CODE> routine is nothing 
more than an indirect <CODE>jmp </CODE>whose pointer variable normally points at 
a piece of code which reads data from the DOS standard input. Since all Standard 
Library input routines call the <CODE>getc</CODE> function to read each 
character you can redirect file input in a manner identical to file 
output.</FONT></P>
<P><FONT face=Arial size=2>The Standard Library <CODE>GetOutAdrs, SetOutAdrs, 
PushOutAdrs,</CODE> and <CODE>PopOutAdrs</CODE> are the four main routines which 
manipulate the output redirection pointer. <CODE>GetOutAdrs</CODE> returns the 
address of the current output routine in the <CODE>es:di </CODE>registers. 
Conversely, <CODE>SetOutAdrs </CODE>expects you to pass the address of a new 
output routine in the <CODE>es:di </CODE>registers and it stores this address 
into the output pointer. <CODE>PushOutAdrs</CODE> and <CODE>PopOutAdrs</CODE> 
push and pop the pointer on an internal stack. These do not use the 80x86's 
hardware stack. You are limited to a small number of pushes and pops. Generally, 
you shouldn't count on being able to push more than four of these addresses onto 
the internal stack without overflowing it.</FONT></P>
<P><FONT face=Arial size=2><CODE>GetInAdrs, SetInAdrs, PushInAdrs, </CODE>and 
<CODE>PopInAdrs</CODE> are the complementary routines for the input vector. They 
let you manipulate the input routine pointer. Note that the stack for 
<CODE>PushInAdrs/PopInAdrs</CODE> is not the same as the stack for 
<CODE>PushOutAdrs/PopOutAdrs</CODE>. Pushes and pops to these two stacks are 
independent of one another. </FONT></P>
<P><FONT face=Arial size=2>Normally, the output pointer (which we will 
henceforth refer to as the output hook) points at the Standard Library routine 
<CODE>PutcStdOut<A 
href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#FOOTNOTE-9">[9]</A></CODE>. 
Therefore, you can return the output hook to its normal initialization state at 
any time by executing the statements<A 
href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#FOOTNOTE-10">[10]</A>:</FONT></P><PRE><FONT face="Courier New" size=2>                mov     di, seg SL_PutcStdOut
                mov     es, di
                mov     di, offset SL_PutcStdOut
                SetOutAdrs</FONT></PRE>
<P><FONT face=Arial size=2>The <CODE>PutcStdOut</CODE> routine writes the 
character in the <CODE>al </CODE>register to the DOS standard output, which 
itself might be redirected to some file or device (using the "&gt;" DOS 
redirection operator). If you want to make sure your output is going to the 
video display, you can always call the <CODE>PutcBIOS</CODE> routine which calls 
the BIOS directly to output a character<A 
href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-10.html#FOOTNOTE-11">[11]</A>. 
You can force all Standard Library output to the standard error device using a 
code sequence like:</FONT></P><PRE><FONT face="Courier New" size=2>                mov     di, seg SL_PutcBIOS
                mov     es, di
                mov     di, offset SL_PutcBIOS
                SetOutAdrs</FONT></PRE>
<P><FONT face=Arial size=2>Generally, you would not simply blast the output hook 
by storing a pointer to your routine over the top of whatever pointer was there 
and then restoring the hook to <CODE>PutcStdOut</CODE> upon completion. Who 
knows if the hook was pointing at <CODE>PutcStdOut</CODE> in the first place? 
The best solution is to use the Standard Library <CODE>PushOutAdrs</CODE> and 
<CODE>PopOutAdrs</CODE> routines to preserve and restore the previous hook. The 
following code demonstrates a gentler way of modifying the output 
hook:</FONT></P><PRE><FONT face="Courier New" size=2>                PushOutAdrs             ;Save current output routine.
                mov     di, seg Output_Routine
                mov     es, di
                mov     di, offset Output_Routine
                SetOutAdrs

        &lt;Do all output to Output_Routine here&gt;

                PopOutAdrs              ;Restore previous output routine.</FONT></PRE>
<P><FONT face=Arial size=2>Handle input in a similar fashion using the 
corresponding input hook access routines and the <CODE>SL_GetcStdOut</CODE> and 
SL_<CODE>GetcBIOS</CODE> routines. Always keep in mind that there are a limited 
number of entries on the input and output hook stacks so what how many items you 
push onto these stacks without popping anything off.</FONT></P>
<P><FONT face=Arial size=2>To redirect output to a file (or redirect input from 
a file) you must first write a short routine which writes (reads) a single 
character from (to) a file. This is very easy. The code for a subroutine to 
output data to a file described by file variable <CODE>OutputFile</CODE> 
is</FONT></P><PRE><FONT face="Courier New" size=2>ToOutput        proc    far
                push    es
                push    di

; Load ES:DI with the address of the OutputFile variable. This
; code assumes OutputFile is of type FileVar, not a pointer to
; a variable of type FileVar.

                mov     di, seg OutputFile
                mov     es, di
                mov     di, offset OutputFile

; Output the character in AL to the file described by "OutputFile"

                fputc

                pop     di
                pop     es
                ret
ToOutput        endp</FONT></PRE>
<P><FONT face=Arial size=2>Now with only one additional piece of code, you can 
begin writing data to an output file using all the Standard Library output 
routines. That is a short piece of code which redirects the output hook to the 
"<CODE>ToOutput</CODE>" routine above:</FONT></P><PRE><FONT face="Courier New" size=2>SetOutFile      proc
                push    es
                push    di

                PushOutAdrs             ;Save current output hook.
                mov     di, seg ToOutput
                mov     es, di
                mov     di, offset ToOutput
                SetOutAdrs

                pop     di
                pop     es
                ret
SetOutFile      endp</FONT></PRE>
<P><FONT face=Arial size=2>There is no need for a separate routine to restore 
the output hook to its previous value; <CODE>PopOutAdrs</CODE> will handle that 
task by itself.</FONT></P>
<HR color=#000000 noShade SIZE=1>

<P><FONT face=Arial size=2><STRONG><A name=FOOTNOTE-8></A>[8]</STRONG> Actually, 
it's declared in file.a. Stdlib.a includes file.a so this definition appears 
inside stdlib.a as well. </FONT></P>
<P><FONT face=Arial size=2><STRONG><A name=FOOTNOTE-9></A>[9]</STRONG> Actually, 
the routine is SL_PutcStdOut. The Standard Library macro by which you would 
normally call this routine is PutcStdOut. </FONT></P>
<P><FONT face=Arial size=2><STRONG><A name=FOOTNOTE-10></A>[10]</STRONG> If you 
do not have any calls to PutcStdOut in your program, you will also need to add 
the statement "externdef SL_PutcStdOut:far" to your program. </FONT></P>
<P><FONT face=Arial size=2><STRONG><A name=FOOTNOTE-11></A>[11]</STRONG> It is 
possible to redirect even the BIOS output, but this is rarely done and not easy 
to do from DOS. </FONT></P>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-9.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 10)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-9.html">Chapter 
      Thirteen</A> (Part 9)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-11.html">Chapter 
      Thirteen</A> (Part 11)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-11.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 10)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<P align=right><FONT face=Arial size=2><STRONG>Chapter Thirteen: MS-DOS, PC-BIOS 
and File I/O (Part 10)<BR>28 SEP 1996</STRONG></FONT></P></BODY></HTML>
