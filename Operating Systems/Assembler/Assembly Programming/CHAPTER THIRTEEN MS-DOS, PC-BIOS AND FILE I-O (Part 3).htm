<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0084)http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html -->
<HTML><HEAD><TITLE>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 3)</TITLE><!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META http-equiv=pragma content=no-cache>
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#000000 link=#008000 bgColor=#ffffff topMargin=10 
stylesrc="../toc.html">
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="100%" colSpan=3>
      <P align=right><A name=top></A><FONT face=Arial size=1>The Art 
      of<BR></FONT><FONT face="Arial Black" size=1>ASSEMBLY LANGUAGE 
      PROGRAMMING</FONT></P></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1><A name=HEADING3></A></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-2.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 3)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-2.html">Chapter 
      Thirteen</A> (Part 2)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html">Chapter 
      Thirteen</A> (Part 4)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 3)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD noWrap width="100%" bgColor=#ffffff colSpan=2 height=10><A 
      name=HEADING3-0></A></TD></TR>
  <TR>
    <TD width="100%" bgColor=#f0f0f0 colSpan=2><FONT face=Arial 
      size=4><STRONG>CHAPTER THIRTEEN:<BR>MS-DOS, PC-BIOS AND FILE I/O (Part 
      3)</STRONG></FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 height=10></TD></TR>
  <TR>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-1"><B>13.2.6 
      </B>- INT 14h - Serial I/O</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-7"><B>13.2.6.1 
      </B>- AH=0: Serial Port Initialization</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-41"><B>13.2.6.2 
      </B>- AH=1: Transmit a Character to the Serial Port</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-52"><B>13.2.6.3 
      </B>- AH=2: Receive a Character from the Serial Port</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-63"><B>13.2.6.4 
      </B>- AH=3: Serial Port Status</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-85"><B>13.2.7 
      </B>- INT 15h - Miscellaneous Services</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-87"><B>13.2.8 
      </B>- INT 16h - Keyboard Services</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-93"><B>13.2.8.1 
      </B>- AH=0: Read a Key From the Keyboard</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-106"><B>13.2.8.2 
      </B>- AH=1: See if a Key is Available at the Keyboard</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-131"><B>13.2.8.3 
      </B>- AH=2: Return Keyboard Shift Key Status</A> </FONT></TD>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-144"><B>13.2.9 
      </B>- INT 17h - Printer Services</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-158"><B>13.2.9.1 
      </B>- AH=0: Print a Character</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-161"><B>13.2.9.2 
      </B>- AH=1: Initialize Printer</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-163"><B>13.2.9.3 
      </B>- AH=2: Return Printer Status</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-181"><B>13.2.10 
      </B>- INT 18h - Run BASIC</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-187"><B>13.2.11 
      </B>- INT 19h - Reboot Computer</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-193"><B>13.2.12 
      </B>- INT 1Ah - Real Time Clock</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-199"><B>13.2.12.1 
      </B>- AH=0: Read the Real Time Clock</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#HEADING3-208"><B>13.2.12.2 
      </B>- AH=1: Setting the Real Time Clock</A> </FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 
height=20></TD></TR></TBODY></TABLE></CENTER></DIV>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-1></A>13.2.6 INT 14h - 
Serial I/O</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Instruction:    int 14h
BIOS Operation: Access the serial communications port
Parameters:     ax, dx</FONT></PRE>
<P><FONT face=Arial size=2>The IBM BIOS supports up to four different serial 
communications ports (the hardware supports up to eight). In general, most PCs 
have one or two serial ports (COM1: and COM2:) installed. <CODE>Int 14h 
</CODE>supports four subfunctions- initialize, transmit a character, receive a 
character, and status. For all four services, the serial port number (a value in 
the range 0..3) is in the <CODE>dx </CODE>register (0=COM1:, 1=COM2:, etc.). 
<CODE>Int 14h </CODE>expects and returns other data in the <CODE>al </CODE>or 
<CODE>ax </CODE>register.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-7></A>13.2.6.1 AH=0: Serial 
Port Initialization</FONT></STRONG></P>
<P><FONT face=Arial size=2>Subfunction zero initializes a serial port. This call 
lets you set the baud rate, select parity modes, select the number of stop bits, 
and the number of bits transmitted over the serial line. These parameters are 
all specified by the value in the <CODE>al </CODE>register using the following 
bit encodings: </FONT></P><PRE><FONT face="Courier New" size=2>Bits    Function 
5..7    Select baud rate
                000- 110 baud
                001- 150
                010- 300
                011- 600
                100- 1200
                101- 2400
                110- 4800
                111- 9600

3..4    Select parity
                00- No parity
                01- Odd parity
                10- No parity
                11- Even parity

2       Stop bits
                 0-One stop bit
                 1-Two stop bits
0..1    Character Size
                 10- 7 bits
                 11- 8 bits</FONT></PRE>
<P><FONT face=Arial size=2>Although the standard PC serial port hardware 
supports 19,200 baud, some BIOSes may not support this speed. </FONT></P>
<P><FONT face=Arial size=2>Example: Initialize COM1: to 2400 baud, no parity, 
eight bit data, and two stop bits-</FONT></P><PRE><FONT face="Courier New" size=2>                mov     ah, 0           ;Initialize opcode
                mov     al, 10100111b   ;Parameter data.
                mov     dx, 0           ;COM1: port.
                int     14h</FONT></PRE>
<P><FONT face=Arial size=2>After the call to the initialization code, the serial 
port status is returned in <CODE>ax </CODE>(see Serial Port Status, 
<CODE>ah</CODE>=3, below).</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-41></A>13.2.6.2 AH=1: 
Transmit a Character to the Serial Port</FONT></STRONG></P>
<P><FONT face=Arial size=2>This function transmits the character in the <CODE>al 
</CODE>register through the serial port specified in the <CODE>dx 
</CODE>register. On return, if <CODE>ah </CODE>contains zero, then the character 
was transmitted properly. If bit 7 of <CODE>ah </CODE>contains one, upon return, 
then some sort of error occurred. The remaining seven bits contain all the error 
statuses returned by the <CODE>GetStatus</CODE> call except time out error 
(which is returned in bit seven). If an error is reported, you should use 
subfunction three to get the actual error values from the serial port hardware. 
</FONT></P>
<P><FONT face=Arial size=2>Example: Transmit a character through the COM1: 
port</FONT></P><PRE><FONT face="Courier New" size=2>                mov     dx, 0           ;Select COM1:
                mov     al, 'a'         ;Character to transmit
                mov     ah, 1           ;Transmit opcode
                int     14h
                test    ah, 80h         ;Check for error
                jnz     SerialError</FONT></PRE>
<P><FONT face=Arial size=2>This function will wait until the serial port 
finishes transmitting the last character (if any) and then it will store the 
character into the transmit register. </FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-52></A>13.2.6.3 AH=2: 
Receive a Character from the Serial Port</FONT></STRONG></P>
<P><FONT face=Arial size=2>Subfunction two is used to read a character from the 
serial port. On entry, <CODE>dx </CODE>contains the serial port number. On exit, 
<CODE>al </CODE>contains the character read from the serial port and bit seven 
of <CODE>ah </CODE>contains the error status. When this routine is called, it 
does not return to the caller until a character is received at the serial port. 
</FONT></P>
<P><FONT face=Arial size=2>Example: Reading a character from the COM1: 
port</FONT></P><PRE><FONT face="Courier New" size=2>                mov     dx, 0           ;Select COM1:
                mov     ah, 2           ;Receive opcode
                int     14h
                test    ah, 80h         ;Check for error
                jnz     SerialError 

        &lt;Received character is now in AL&gt;</FONT></PRE><PRE><STRONG><FONT face=Arial size=3>13.2.6.4 AH=3: Serial Port Status</FONT></STRONG></PRE>
<P><FONT face=Arial size=2>This call returns status information about the serial 
port including whether or not an error has occurred, if a character has been 
received in the receive buffer, if the transmit buffer is empty, and other 
pieces of useful information. On entry into this routine, the <CODE>dx 
</CODE>register contains the serial port number. On exit, the <CODE>ax 
</CODE>register contains the following values: </FONT></P><PRE><FONT face="Courier New" size=2>AX:     Bit Meaning 
15      Time out error
14      Transmitter shift register empty
13      Transmitter holding register empty
12      Break detection error
11      Framing error
10      Parity error
9       Overrun error
8       Data available
7       Receive line signal detect 
6       Ring indicator
5       Data set ready (DSR)
4       Clear to send (CTS)
3       Delta receive line signal detect
2       Trailing edge ring detector
1       Delta data set ready
0       Delta clear to send</FONT></PRE>
<P><FONT face=Arial size=2>There are a couple of useful bits, not pertaining to 
errors, returned in this status information. If the data available bit is set 
(bit #8), then the serial port has received data and you should read it from the 
serial port. The Transmitter holding register empty bit (bit #13) tells you if 
the transmit operation will be delayed while waiting for the current character 
to be transmitted or if the next character will be immediately transmitted. By 
testing these two bits, you can perform other operations while waiting for the 
transmit register to become available or for the receive register to contain a 
character.</FONT></P>
<P><FONT face=Arial size=2>If you're interested in serial communications, you 
should obtain a copy of Joe Campbell's C Programmer's Guide to Serial 
Communications. Although written specifically for C programmers, this book 
contains a lot of information useful to programmers working in any programming 
language. See the bibliography for more details.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-85></A>13.2.7 INT 15h - 
Miscellaneous Services</FONT></STRONG></P>
<P><FONT face=Arial size=2>Originally, <CODE>int 15h </CODE>provided cassette 
tape read and write services<A 
href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-3.html#FOOTNOTE-1">[1]</A>. 
Almost immediately, everyone realized that cassettes were history, so IBM began 
using <CODE>int 15h </CODE>for many other services. Today, <CODE>int 15h 
</CODE>is used for a wide variety of function including accessing expanded 
memory, reading the joystick/game adapter card, and many, many other operations. 
Except for the joystick calls, most of these services are beyond the scope of 
this text. Check on the bibliography if you interested in obtaining information 
on this BIOS call. </FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-87></A>13.2.8 INT 16h - 
Keyboard Services</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Instruction:    int 16h
BIOS Operation: Read a key, test for a key, or get keyboard status
Parameters:     al</FONT></PRE>
<P><FONT face=Arial size=2>The IBM PC BIOS provides several function calls 
dealing with the keyboard. As with many of the PC BIOS routines, the number of 
functions has increased over the years. This section describes the three calls 
that were available on the original IBM PC. </FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-93></A>13.2.8.1 AH=0: Read a 
Key From the Keyboard</FONT></STRONG></P>
<P><FONT face=Arial size=2>If<CODE> int 16h</CODE> is called with <CODE>ah 
</CODE>equal to zero, the BIOS will not return control to the caller until a key 
is available in the system type ahead buffer. On return, <CODE>al 
</CODE>contains the ASCII code for the key read from the buffer and <CODE>ah 
</CODE>contains the keyboard scan code. Keyboard scan codes are described in the 
appendices. </FONT></P>
<P><FONT face=Arial size=2>Certain keys on the PC's keyboard do not have any 
corresponding ASCII codes. The function keys, Home, PgUp, End, PgDn, the arrow 
keys, and the Alt keys are all good examples. When such a key is pressed, 
<CODE>int 16h </CODE>returns a zero in <CODE>al </CODE>and the keyboard scan 
code in <CODE>ah</CODE>. Therefore, whenever an ASCII code of zero is returned, 
you must check the <CODE>ah </CODE>register to determine which key was pressed. 
</FONT></P>
<P><FONT face=Arial size=2>Note that reading a key from the keyboard using the 
BIOS <CODE>int 16h </CODE>call does not echo the key pressed to the display. You 
have to call <CODE>putc</CODE> or use <CODE>int 10h </CODE>to print the 
character once you've read it if you want it echoed to the screen. </FONT></P>
<P><FONT face=Arial size=2>Example: Read a sequence of keystrokes from the 
keyboard until Enter is pressed.</FONT></P><PRE><FONT face="Courier New" size=2>ReadLoop:       mov     ah, 0           ;Read Key opcode
                int     16h
                cmp     al, 0           ;Special function?
                jz      ReadLoop        ;If so, don't echo this keystroke
                putc
                cmp     al, 0dh         ;Carriage return (ENTER)?
                jne     ReadLoop</FONT></PRE><PRE><STRONG><FONT face=Arial size=3>13.2.8.2 AH=1: See if a Key is Available at the Keyboard</FONT></STRONG></PRE>
<P><FONT face=Arial size=2>This particular <CODE>int 16h </CODE>subfunction 
allows you to check to see if a key is available in the system type ahead 
buffer. Even if a key is not available, control is returned (right away!) to the 
caller. With this call you can occasionally poll the keyboard to see if a key is 
available and continue processing if a key hasn't been pressed (as opposed to 
freezing up the computer until a key is pressed).</FONT></P>
<P><FONT face=Arial size=2>There are no input parameters to this function. On 
return, the zero flag will be clear if a key is available, set if there aren't 
any keys in the type ahead buffer. If a key is available, then <CODE>ax 
</CODE>will contain the scan and ASCII codes for that key. However, this 
function will not remove that keystroke from the typeahead buffer. Subfunction 
#0 must be used to remove characters. The following example demonstrates how to 
build a random number generator using the test keyboard function: </FONT></P>
<P><FONT face=Arial size=2>Example: Generating a random number while waiting for 
a keystroke</FONT></P><PRE><FONT face="Courier New" size=2>; First, clear any characters out of the type ahead buffer

ClrBuffer:      mov     ah, 1           ;Is a key available?
                int     16h
                jz      BufferIsClr     ;If not, Discontinue flushing
                mov     ah, 0           ;Flush this character from the
                int     16h             ; buffer and try again.
                jmp     ClrBuffer

BufferIsClr:    mov     cx, 0           ;Initialize "random" number.
GenRandom:      inc     cx
                mov     ah, 1           ;See if a key is available yet.
                int     16h
                jz      GenRandom
                xor     cl, ch          ;Randomize even more.
                mov     ah, 0           ;Read character from buffer
                int     16h

; Random number is now in CL, key pressed by user is in AX</FONT></PRE>
<P><FONT face=Arial size=2>While waiting for a key, this routine is constantly 
incrementing the <CODE>cx </CODE>register. Since human beings cannot respond 
rapidly (at least in terms of microseconds) the <CODE>cl </CODE>register will 
overflow many times, even for the fastest typist. As a result, <CODE>cl 
</CODE>will contain a random value since the user will not be able to control 
(to better than about 2ms) when a key is pressed.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-131></A>13.2.8.3 AH=2: 
Return Keyboard Shift Key Status</FONT></STRONG></P>
<P><FONT face=Arial size=2>This function returns the state of various keys on 
the PC keyboard in the <CODE>al </CODE>register. The values returned are as 
follows:</FONT></P><PRE><FONT face="Courier New" size=2>Bit     Meaning 
7       Insert state (toggle by pressing INS key)
6       Caps lock (1=capslock on)
5       Num lock (1=numlock on)
4       Scroll lock (1=scroll lock on)
3       Alt (1=Alt key currently down)
2       Ctrl (1=Ctrl key currently down)
1       Left shift (1=left shift key down)
0       Right shift (1=right shift key down)</FONT></PRE>
<P><FONT face=Arial size=2>Due to a bug in the BIOS code, these bits only 
reflect the current status of these keys, they do not necessarily reflect the 
status of these keys when the next key to be read from the system type ahead 
buffer was depressed. In order to ensure that these status bits correspond to 
the state of these keys when a scan code is read from the type ahead buffer, 
you've got to flush the buffer, wait until a key is pressed, and then 
immediately check the keyboard status.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-144></A>13.2.9 INT 17h - 
Printer Services</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Instruction:    int 17h
BIOS Operation: Print data and test the printer status
Parameters:     ax, dx</FONT></PRE><CODE>
<P><FONT face=Arial size=2>Int 17h </CODE>controls the parallel printer 
interfaces on the IBM PC in much the same way the <CODE>int 14h </CODE>controls 
the serial ports. Since programming a parallel port is considerably easier than 
controlling a serial port, using the<CODE> int 17h </CODE>routine is somewhat 
easier than using the <CODE>int 14h </CODE>routines. </FONT></P>
<P><FONT face=Arial size=2><CODE>Int 17h </CODE>provides three subfunctions, 
specified by the value in the <CODE>ah </CODE>register. These subfunctions are: 
</FONT></P>
<P><FONT face=Arial size=2>0-Print the character in the AL register. </FONT></P>
<P><FONT face=Arial size=2>1-Initialize the printer. </FONT></P>
<P><FONT face=Arial size=2>2-Return the printer status. </FONT></P>
<P><FONT face=Arial size=2>Each of these functions is described in the following 
sections. </FONT></P>
<P><FONT face=Arial size=2>Like the serial port services, the printer port 
services allow you to specify which of the three printers installed in the 
system you wish to use (LPT1:, LPT2:, or LPT3:). The value in the <CODE>dx 
</CODE>register (0..2) specifies which printer port is to be used. </FONT></P>
<P><FONT face=Arial size=2>One final note- under DOS it's possible to redirect 
all printer output to a serial port. This is quite useful if you're using a 
serial printer. The BIOS printer services only talk to parallel printer 
adapters. If you need to send data to a serial printer using BIOS, you'll have 
to use<CODE> int 14h</CODE> to transmit the data through a serial 
port.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-158></A>13.2.9.1 AH=0: Print 
a Character</FONT></STRONG></P>
<P><FONT face=Arial size=2>If <CODE>ah </CODE>is zero when you call <CODE>int 
17h</CODE>, then the BIOS will print the character in the <CODE>al 
</CODE>register. Exactly how the character code in the <CODE>al </CODE>register 
is treated is entirely up to the printer device you're using. Most printers, 
however, respect the printable ASCII character set and a few control characters 
as well. Many printers will also print all the symbols in the IBM/ASCII 
character set (including European, line drawing, and other special symbols). 
Most printers treat control characters (especially ESC sequences) in completely 
different manners. Therefore, if you intend to print something other than 
standard ASCII characters, be forewarned that your software may not work on 
printers other than the brand you're developing your software on. </FONT></P>
<P><FONT face=Arial size=2>Upon return from the <CODE>int 17h </CODE>subfunction 
zero routine, the <CODE>ah </CODE>register contains the current status. The 
values actually returned are described in the section on subfunction number 
two.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-161></A>13.2.9.2 AH=1: 
Initialize Printer</FONT></STRONG></P>
<P><FONT face=Arial size=2>Executing this call sends an electrical impulse to 
the printer telling it to initialize itself. On return, the <CODE>ah 
</CODE>register contains the printer status as per function number 
two.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-163></A>13.2.9.3 AH=2: 
Return Printer Status</FONT></STRONG></P>
<P><FONT face=Arial size=2>This function call checks the printer status and 
returns it in the <CODE>ah </CODE>register. The values returned are:</FONT></P><PRE><FONT face="Courier New" size=2>AH:     Bit Meaning 
7       1=Printer busy, 0=printer not busy
6       1=Acknowledge from printer
5       1=Out of paper signal
4       1=Printer selected
3       1=I/O error
2       Not used
1       Not used
0       Time out error</FONT></PRE>
<P><FONT face=Arial size=2>Acknowledge from printer is, essentially, a redundant 
signal (since printer busy/not busy gives you the same information). As long as 
the printer is busy, it will not accept additional data. Therefore, calling the 
print character function (<CODE>ah</CODE>=0) will result in a delay. </FONT></P>
<P><FONT face=Arial size=2>The out of paper signal is asserted whenever the 
printer detects that it is out of paper. This signal is not implemented on many 
printer adapters. On such adapters it is always programmed to a logic zero (even 
if the printer is out of paper). Therefore, seeing a zero in this bit position 
doesn't always guarantee that there is paper in the machine. Seeing a one here, 
however, definitely means that your printer is out of paper. </FONT></P>
<P><FONT face=Arial size=2>The printer selected bit contains a one as long as 
the printer is on-line. If the user takes the printer off-line, then this bit 
will be cleared. </FONT></P>
<P><FONT face=Arial size=2>The I/O error bit contains a one if some general I/O 
error has occurred. </FONT></P>
<P><FONT face=Arial size=2>The time out error bit contains a one if the BIOS 
routine waited for an extended period of time for the printer to become "not 
busy" yet the printer remained busy. </FONT></P>
<P><FONT face=Arial size=2>Note that certain peripheral devices (other than 
printers) also interface to the parallel port, often in addition to a parallel 
printer. Some of these devices use the error/status signal lines to return data 
to the PC. The software controlling such devices often takes over the <CODE>int 
17h </CODE>routine (via a technique we'll talk about later on) and always 
returns a "no error" status or "time out error" status if an error occurs on the 
printing device. Therefore, you should take care not to depend too heavily on 
these signals changing when you make the <CODE>int 17h </CODE>BIOS 
calls.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-181></A>13.2.10 INT 18h - 
Run BASIC</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Instruction:    int 18h
BIOS Operation: Activate ROM BASIC
Parameters:     None </FONT></PRE>
<P><FONT face=Arial size=2>Executing <CODE>int 18h </CODE>activates the ROM 
BASIC interpreter in an IBM PC. However, you shouldn't use this mechanism to run 
BASIC since many PC compatibles do not have BASIC in ROM and the result of 
executing <CODE>int 18h </CODE>is undefined.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-187></A>13.2.11 INT 19h - 
Reboot Computer</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Instruction:    int 19h 
BIOS Operation: Restart the system
Parameters:     None </FONT></PRE>
<P><FONT face=Arial size=2>Executing this interrupt has the same effect as 
pressing control-alt-del on the keyboard. For obvious reasons, this interrupt 
service should be handled carefully!</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-193></A>13.2.12 INT 1Ah - 
Real Time Clock</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Instruction:    int 1ah
BIOS Operation: Real time clock services
Parameters:     ax, cx, dx</FONT></PRE>
<P><FONT face=Arial size=2>There are two services provided by this BIOS routine- 
read the clock and set the clock. The PC's real time clock maintains a counter 
that counts the number of 1/18ths of a second that have transpired since 
midnight. When you read the clock, you get the number of "ticks" which have 
occurred since then. When you set the clock, you specify the number of "ticks" 
which have occurred since midnight. As usual, the particular service is selected 
via the value in the <CODE>ah </CODE>register.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-199></A>13.2.12.1 AH=0: Read 
the Real Time Clock</FONT></STRONG></P>
<P><FONT face=Arial size=2>If <CODE>ah </CODE>= 0, then <CODE>int 1ah 
</CODE>returns a 33-bit value in <CODE>al:cx:dx </CODE>as follows: </FONT></P><PRE><FONT face="Courier New" size=2>Reg     Value Returned 
dx      L.O. word of clock count
cx      H.O. word of clock count
al      Zero if timer has not run for more than 24 hours
        Non-zero otherwise.</FONT></PRE>
<P><FONT face=Arial size=2>The 32-bit value in <CODE>cx:dx </CODE>represents the 
number of 55 millisecond periods which have elapsed since midnight.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING3-208></A>13.2.12.2 AH=1: 
Setting the Real Time Clock</FONT></STRONG></P>
<P><FONT face=Arial size=2>This call allows you to set the current system time 
value. <CODE>cx:dx </CODE>contains the current count (in 55ms increments) since 
last midnight. <CODE>Cx </CODE>contains the H.O. word, <CODE>dx </CODE>contains 
the L.O. word.</FONT></P>
<HR color=#000000 noShade SIZE=1>

<P><FONT face=Arial size=2><STRONG><A name=FOOTNOTE-1></A>[1]</STRONG> For those 
who do not remember that far back, before there were hard disks people used to 
use only floppy disks. And before there were floppy disks, people used to use 
cassette tapes to store programs and data. The original IBM PC was introduced in 
late 1981 with a cassette port. By early 1982, no one was using cassette tape 
for data storage.</FONT></P>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-2.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 3)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-2.html">Chapter 
      Thirteen</A> (Part 2)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html">Chapter 
      Thirteen</A> (Part 4)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-4.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 3)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<P align=right><FONT face=Arial size=2><STRONG>Chapter Thirteen: MS-DOS, PC-BIOS 
and File I/O (Part 3)<BR>28 SEP 1996</STRONG></FONT></P></BODY></HTML>
