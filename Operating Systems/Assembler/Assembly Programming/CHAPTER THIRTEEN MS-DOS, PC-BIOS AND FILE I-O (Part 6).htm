<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0084)http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html -->
<HTML><HEAD><TITLE>CHAPTER THIRTEEN: MS-DOS, PC-BIOS AND FILE I/O (Part 6)</TITLE><!-- Generated by Harlequin WebMaker 2.2.6 (30-Apr-1996)Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META http-equiv=pragma content=no-cache>
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#000000 link=#008000 bgColor=#ffffff topMargin=10 
stylesrc="../toc.html">
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD width="100%" colSpan=3>
      <P align=right><A name=top></A><FONT face=Arial size=1>The Art 
      of<BR></FONT><FONT face="Arial Black" size=1>ASSEMBLY LANGUAGE 
      PROGRAMMING</FONT></P></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1><A name=HEADING6></A></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 6)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html">Chapter 
      Thirteen</A> (Part 5)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-7.html">Chapter 
      Thirteen</A> (Part 7)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-7.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 6)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD noWrap width="100%" bgColor=#ffffff colSpan=2 height=10><A 
      name=HEADING6-1></A></TD></TR>
  <TR>
    <TD width="100%" bgColor=#f0f0f0 colSpan=2><FONT face=Arial 
      size=4><STRONG>CHAPTER THIRTEEN:<BR>MS-DOS, PC-BIOS AND FILE I/O (Part 
      6)</STRONG></FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 height=10></TD></TR>
  <TR>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-1"><B>13.3.8 
      </B>- MS-DOS "New" Filing Calls</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-14"><B>13.3.8.1 
      </B>- Open File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-42"><B>13.3.8.2 
      </B>- Create File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-67"><B>13.3.8.3 
      </B>- Close File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-79"><B>13.3.8.4 
      </B>- Read From a File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-121"><B>13.3.8.5 
      </B>- Write to a File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-137"><B>13.3.8.6 
      </B>- Seek (Move File Pointer)</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-169"><B>13.3.8.7 
      </B>- Set Disk Transfer Address (DTA)</A> </FONT></TD>
    <TD vAlign=top width="50%"><FONT face=Arial size=2><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-176"><B>13.3.8.8 
      </B>- Find First File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-201"><B>13.3.8.9 
      </B>- Find Next File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-232"><B>13.3.8.10 
      </B>- Delete File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-243"><B>13.3.8.11 
      </B>- Rename File</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-286"><B>13.3.8.12 
      </B>- Change/Get File Attributes</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-304"><B>13.3.8.13 
      </B>- Get/Set File Date and Time</A> <BR><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-6.html#HEADING6-321"><B>13.3.8.14 
      </B>- Other DOS Calls</A> </FONT></TD></TR>
  <TR>
    <TD noWrap width="100%" colSpan=2 
height=20></TD></TR></TBODY></TABLE></CENTER></DIV>
<H3><STRONG><FONT face=Arial size=3>13.3.8 MS-DOS "New" Filing 
Calls</FONT></STRONG></H3>
<P><FONT face=Arial size=2>Starting with DOS v2.0, Microsoft introduced a set of 
file handling procedures which (finally) made disk file access bearable under 
MS-DOS. Not only bearable, but actually easy to use! The following sections 
describe the use of these commands to access files on a disk drive. </FONT></P>
<P><FONT face=Arial size=2>File commands which deal with filenames (Create, 
Open, Delete, Rename, and others) are passed the address of a zero-terminated 
pathname. Those that actually open a file (Create and Open) return a file handle 
as the result (assuming, of course, that there wasn't an error). This file 
handle is used with other calls (read, write, seek, close, etc.) to gain access 
to the file you've opened. In this respect, a file handle is not unlike a file 
variable in Pascal. Consider the following Microsoft/Turbo Pascal code: 
</FONT></P><PRE><FONT face="Courier New" size=2>        program DemoFiles; var  F:TEXT;
        begin
                assign(f,'FileName.TXT');
                rewrite(f);
                writeln(f,'Hello there');
                close(f);
        end. </FONT></PRE>
<P><FONT face=Arial size=2>The file variable "f" is used in this Pascal example 
in much the same way that a file handle is used in an assembly language program 
- to gain access to the file that was created in the program. </FONT></P>
<P><FONT face=Arial size=2>All the following DOS filing commands return an error 
status in the carry flag. If the carry flag is clear when DOS returns to your 
program, then the operation was completed successfully. If the carry flag is set 
upon return, then some sort of error has occurred and the AX register contains 
the error number. The actual error return values will be discussed along with 
each function in the following sections.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-14></A>13.3.8.1 Open 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  3Dh
Entry parameters:
                al- file access value
                        0- File opened for reading 
                        1- File opened for writing
                        2- File opened for reading and writing
                ds:dx- Point at a zero terminated string containing the filename.
Exit parameters:        
                If the carry is set, ax contains one of the following error codes:
                        2- File not found 
                        4- Too many open files
                        5- Access denied 
                        12- Invalid access
        
                If the carry is clear, 
                        ax contains the file handle value assigned by DOS.</FONT></PRE>
<P><FONT face=Arial size=2>A file must be opened before you can access it. The 
open command opens a file that already exists. This makes it quite similar to 
Pascal's Reset procedure. Attempting to open a file that doesn't exist produces 
an error. Example:</FONT></P><PRE><FONT face="Courier New" size=2>                lea     dx, Filename    ;Assume DS points at segment
                mov     ah, 3dh         ; of filename
                mov     al, 0           ;Open for reading.
                int     21h
                jc      OpenError
                mov     FileHandle, ax</FONT></PRE>
<P><FONT face=Arial size=2>If an error occurs while opening a file, the file 
will not be opened. You should always check for an error after executing a DOS 
open command, since continuing to operate on the file which hasn't been properly 
opened will produce disastrous consequences. Exactly how you handle an open 
error is up to you, but at the very least you should print an error message and 
give the user the opportunity to specify a different filename. </FONT></P>
<P><FONT face=Arial size=2>If the open command completes without generating an 
error, DOS returns a file handle for that file in the <CODE>ax </CODE>register. 
Typically, you should save this value away somewhere so you can use it when 
accessing the file later on.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-42></A>13.3.8.2 Create 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  3Ch
Entry parameters:
                ds:dx- Address of zero terminated pathname
                cx- File attribute
Exit parameters:
                If the carry is set, ax contains one of the following error codes:
                 3- Path not found      
                 4- Too many open files
                 5- Access denied
                If the carry is clear, 
                 ax is returned containing the file handle</FONT></PRE>
<P><FONT face=Arial size=2>Create opens a new file for output. As with the OPEN 
command, <CODE>ds:dx </CODE>points at a zero terminated string containing the 
filename. Since this call creates a new file, DOS assumes that you're opening 
the file for writing only. Another parameter, passed in <CODE>cx</CODE>, is the 
initial file attribute settings. The L.O. six bits of <CODE>cx </CODE>contain 
the following values: </FONT></P><PRE><FONT face="Courier New" size=2>Bit     Meaning if equal to one 
0       File is a Read-Only file
1       File is a hidden file 
2       File is a system file
3       File is a volume label name
4       File is a subdirectory
5       File has been archived</FONT></PRE>
<P><FONT face=Arial size=2>In general, you shouldn't set any of these bits. Most 
normal files should be created with a file attribute of zero. Therefore, the 
<CODE>cx </CODE>register should be loaded with zero before calling the create 
function. </FONT></P>
<P><FONT face=Arial size=2>Upon exit, the carry flag is set if an error occurs. 
The "Path not found" error requires some additional explanation. This error is 
generated, not if the file isn't found (which would be most of the time since 
this command is typically used to create a new file), but if a subdirectory in 
the pathname cannot be found. </FONT></P>
<P><FONT face=Arial size=2>If the carry flag is clear when DOS returns to your 
program, then the file has been properly opened for output and the <CODE>ax 
</CODE>register contains the file handle for this file.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-67></A>13.3.8.3 Close 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  3Eh
Entry parameters:       
                bx- File Handle
Exit parameters:        
                If the carry flag is set, 
                 ax contains 6, the only possible error, 
                 which is an invalid handle error.</FONT></PRE>
<P><FONT face=Arial size=2>This call is used to close a file opened with the 
Open or Create commands above. It is passed the file handle in the <CODE>bx 
</CODE>register and, assuming the file handle is valid, closes the specified 
file. </FONT></P>
<P><FONT face=Arial size=2>You should close all files your program uses as soon 
as you're through with them to avoid disk file corruption in the event the user 
powers the system down or resets the machine while your files are left open. 
</FONT></P>
<P><FONT face=Arial size=2>Note that quitting to DOS (or aborting to DOS by 
pressing control-C or control-break) automatically closes all open files. 
However, you should never rely on this feature since doing so is an extremely 
poor programming practice.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-79></A>13.3.8.4 Read From a 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):    3Fh
Entry parameters:
                  bx- File handle 
                  cx- Number of bytes to read
                  ds:dx- Array large enough to hold bytes read
Exit parameters:        
                  If the carry flag is set, 
                  ax contains one of the following error codes
                  5- Access denied
                  6- Invalid handle
                  If the carry flag is clear, 
                  ax contains the number of bytes actually read from the file.</FONT></PRE>
<P><FONT face=Arial size=2>The read function is used to read some number of 
bytes from a file. The actual number of bytes is specified by the <CODE>cx 
</CODE>register upon entry into DOS. The file handle, which specifies the file 
from which the bytes are to be read, is passed in the <CODE>bx </CODE>register. 
The <CODE>ds:dx </CODE>register contains the address of a buffer into which the 
bytes read from the file are to be stored. </FONT></P>
<P><FONT face=Arial size=2>On return, if there wasn't an error, the <CODE>ax 
</CODE>register contains the number of bytes actually read. Unless the end of 
file (EOF) was reached, this number will match the value passed to DOS in the 
<CODE>cx </CODE>register. If the end of file has been reached, the value return 
in <CODE>ax </CODE>will be somewhere between zero and the value passed to DOS in 
the <CODE>cx </CODE>register. This is the only test for the EOF condition. 
</FONT></P>
<P><FONT face=Arial size=2>Example: This example opens a file and reads it to 
the EOF</FONT></P><PRE><FONT face="Courier New" size=2>                mov     ah, 3dh         ;Open the file
                mov     al, 0           ;Open for reading
                lea     dx, Filename    ;Presume DS points at filename
                int     21h             ; segment.
                jc      BadOpen
                mov     FHndl, ax       ;Save file handle

LP:             mov     ah,3fh          ;Read data from the file
                lea     dx, Buffer      ;Address of data buffer
                mov     cx, 1           ;Read one byte
                mov     bx, FHndl       ;Get file handle value
                int     21h
                jc      ReadError
                cmp     ax, cx          ;EOF reached?
                jne     EOF
                mov     al, Buffer      ;Get character read
                putc                    ;Print it
                jmp     LP              ;Read next byte

EOF:            mov     bx, FHndl
                mov     ah, 3eh         ;Close file
                int     21h
                jc      CloseError</FONT></PRE>
<P><FONT face=Arial size=2>This code segment will read the entire file whose 
(zero-terminated) filename is found at address "Filename" in the current data 
segment and write each character in the file to the standard output device using 
the UCR StdLib <CODE>putc</CODE> routine. Be forewarned that 
one-character-at-a-time I/O such as this is extremely slow. We'll discuss better 
ways to quickly read a file a little later in this chapter.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-121></A>13.3.8.5 Write to a 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):    40h
Entry parameters:       
                  bx- File handle
                  cx- Number of bytes to write
                  ds:dx- Address of buffer containing data to write
Exit parameters:        
                  If the carry is set, 
                  ax contains one of the following error codes
                  5- Accessed denied 
                  6- Invalid handle
                  If the carry is clear on return, 
                  ax contains the number of bytes actually written to the file. </FONT></PRE>
<P><FONT face=Arial size=2>This call is almost the converse of the read command 
presented earlier. It writes the specified number of bytes at <CODE>ds:dx 
</CODE>to the file rather than reading them. On return, if the number of bytes 
written to the file is not equal to the number originally specified in the 
<CODE>cx </CODE>register, the disk is full and this should be treated as an 
error. </FONT></P>
<P><FONT face=Arial size=2>If <CODE>cx </CODE>contains zero when this function 
is called, DOS will truncate the file to the current file position (i.e., all 
data following the current position in the file will be deleted).</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-137></A>3.3.8.6 Seek (Move 
File Pointer)</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  42h Entry parameters:
                al- Method of moving
                 0- Offset specified is from the beginning of the file. 
                 1- Offset specified is distance from the current file pointer.
                 2- The pointer is moved to the end of the file minus the specified offset.
                bx- File handle. 
                cx:dx- Distance to move, in bytes.
Exit parameters:        
                If the carry is set, 
                 ax contains one of the following error codes
                  1- Invalid function 
                  6- Invalid handle
                If the carry is clear, 
                 dx:ax contains the new file position</FONT></PRE>
<P><FONT face=Arial size=2>This command is used to move the file pointer around 
in a random access file. There are three methods of moving the file pointer, an 
absolute distance within the file (if <CODE>al</CODE>=0), some positive distance 
from the current file position (if <CODE>al</CODE>=1), or some distance from the 
end of the file (if <CODE>al</CODE>=2). If AL doesn't contain 0, 1, or 2, DOS 
will return an invalid function error. If this call is successfully completed, 
the next byte read or written will occur at the specified location. </FONT></P>
<P><FONT face=Arial size=2>Note that DOS treats <CODE>cx:dx </CODE>as an 
unsigned integer. Therefore, a single seek command cannot be used to move 
backwards in the file. Instead, method #0 must be used to position the file 
pointer at some absolute position in the file. If you don't know where you 
currently are and you want to move back 256 bytes, you can use the following 
code:</FONT></P><PRE><FONT face="Courier New" size=2>                mov     ah, 42h         ;Seek command
                mov     al, 1           ;Move from current location
                xor     cx, cx          ;Zero out CX and DX so we
                xor     dx, dx          ; stay right here
                mov     bx, FileHandle
                int     21h
                jc      SeekError
                sub     ax, 256         ;DX:AX now contains the
                sbb     dx, 0           ; current file position, so
                mov     cx, dx          ; compute a location 256 
                mov     dx, ax          ; bytes back.
                mov     ah, 42h
                mov     al, 0           ;Absolute file position
                int     21h             ;BX still contains handle.</FONT></PRE><PRE><STRONG><FONT face=Arial size=3>13.3.8.7 Set Disk Transfer Address (DTA)</FONT></STRONG></PRE><PRE><FONT face="Courier New" size=2>Function (ah):  1Ah Entry parameters:
                ds:dx- Pointer to DTA
Exit parameters:        
                None</FONT></PRE>
<P><FONT face=Arial size=2>This command is called "Set Disk Transfer Address" 
because it was (is) used with the original DOS v1.0 file functions. We wouldn't 
normally consider this function except for the fact that it is also used by 
functions 4Eh and 4Fh (described next) to set up a pointer to a 43-byte buffer 
area. If this function isn't executed before executing functions 4Eh or 4Fh, DOS 
will use the default buffer space at PSP:80h.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-176></A>13.3.8.8 Find First 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):    4Eh
Entry parameters:       
                  cx- Attributes 
                  ds:dx- Pointer to filename
Exit parameters:        
                  If carry is set, 
                  ax contains one of the following error codes
                   2- File not found 
                  18- No more files </FONT></PRE>
<P><FONT face=Arial size=2>The Find First File and Find Next File (described 
next) functions are used to search for files specified using ambiguous file 
references. An ambiguous file reference is any filename containing the "*" and 
"?" wildcard characters. The Find First File function is used to locate the 
first such filename within a specified directory, the Find Next File function is 
used to find successive entries in the directory. </FONT></P>
<P><FONT face=Arial size=2>Generally, when an ambiguous file reference is 
provided, the Find First File command is issued to locate the first occurrence 
of the file, and then a loop is used, calling Find Next File, to locate all 
other occurrences of the file within that loop until there are no more files 
(error #18). Whenever Find First File is called, it sets up the following 
information at the DTA: </FONT></P><PRE><FONT face="Courier New" size=2>Offset  Description 
0       Reserved for use by Find Next File 
21      Attribute of file found
22      Time stamp of file
24      Date stamp of file
26      File size in bytes
30      Filename and extension (zero terminated)</FONT></PRE>
<P><FONT face=Arial size=2>(The offsets are decimal) </FONT></P>
<P><FONT face=Arial size=2>Assuming Find First File doesn't return some sort of 
error, the name of the first file matching the ambiguous file description will 
appear at offset 30 in the DTA.</FONT></P>
<P><FONT face=Arial size=2>Note: if the specified pathname doesn't contain any 
wildcard characters, then Find First File will return the exact filename 
specified, if it exists. Any subsequent call to Find Next File will return an 
error. </FONT></P>
<P><FONT face=Arial size=2>The <CODE>cx </CODE>register contains the search 
attributes for the file. Normally, <CODE>cx </CODE>should contain zero. If 
non-zero, Find First File (and Find Next File) will include file names which 
have the specified attributes as well as all normal file names.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-201></A>13.3.8.9 Find Next 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  4Fh
Entry parameters:       
                none
Exit parameters:        
                If the carry is set, 
                then there aren't any more files and 
                ax will be returned containing 18.</FONT></PRE>
<P><FONT face=Arial size=2>The Find Next File function is used to search for 
additional file names matching an ambiguous file reference after a call to Find 
First File. The DTA must point at a data record set up by the Find First File 
function. </FONT></P>
<P><FONT face=Arial size=2>Example: The following code lists the names of all 
the files in the current directory that end with ".EXE". Presumably, the 
variable "DTA" is in the current data segment:</FONT></P><PRE><FONT face="Courier New" size=2>                mov     ah, 1Ah         ;Set DTA
                lea     dx, DTA
                int     21h
                xor     cx, cx          ;No attributes.
                lea     dx, FileName
                mov     ah, 4Eh         ;Find First File
                int     21h
                jc      NoMoreFiles     ;If error, we're done
DirLoop:        lea     si, DTA+30      ;Address of filename
                cld
PrtName:        lodsb
                test    al, al          ;Zero byte?
                jz      NextEntry
                putc                    ;Print this character
                jmp     PrtName

NextEntry:      mov     ah, 4Fh         ;Find Next File
                int     21h
                jnc     DirLoop         ;Print this name</FONT></PRE><PRE><STRONG><FONT face=Arial size=3>13.3.8.10 Delete File</FONT></STRONG></PRE><PRE><FONT face="Courier New" size=2>Function (ah):  41h
Entry parameters:       
                ds:dx- Address of pathname to delete
Exit parameters:        
                If carry set, 
                 ax contains one of the following error codes
                  2- File not found
                  5- Access denied</FONT></PRE>
<P><FONT face=Arial size=2>This function will delete the specified file from the 
directory. The filename must be an unambiguous filename (i.e., it cannot contain 
any wildcard characters).</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-243></A>13.3.8.11 Rename 
File</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  56h Entry parameters:
                ds:dx- Pointer to pathname of existing file 
                es:di- Pointer to new pathname
Exit parameters:        
                If carry set, 
                 ax contains one of the following error codes
                   2- File not found 
                   5- Access denied
                  17- Not the same device</FONT></PRE>
<P><FONT face=Arial size=2>This command serves two purposes: it allows you to 
rename one file to another and it allows you to move a file from one directory 
to another (as long as the two subdirectories are on the same disk). </FONT></P>
<P><FONT face=Arial size=2>Example: Rename "MYPGM.EXE" to 
"YOURPGM.EXE"</FONT></P><PRE><FONT face="Courier New" size=2>; Assume ES and DS both point at the current data segment
; containing the filenames.

                lea     dx, OldName 
                lea     di, NewName
                mov     ah, 56h
                int     21h
                jc      BadRename 
                         . 
                         . 
                         .
OldName         byte    "MYPGM.EXE",0
NewName         byte    "YOURPGM.EXE",0</FONT></PRE>
<P><FONT face=Arial size=2>Example #2: Move a filename from one directory to 
another: </FONT></P><PRE><FONT face="Courier New" size=2>; Assume ES and DS both point at the current data segment
; containing the filenames.

                lea     dx, OldName
                lea     di, NewName
                mov     ah, 56h
                int     21h
                jc      BadRename
                         .
                         .
                         .
OldName         byte    "\DIR1\MYPGM.EXE",0
NewName         byte    "\DIR2\MYPGM.EXE",0</FONT></PRE><PRE><STRONG><FONT face=Arial size=3>13.3.8.12 Change/Get File Attributes</FONT></STRONG></PRE><PRE><FONT face="Courier New" size=2>Function (ah):  43h
Entry parameters:       
                al- Subfunction code
                 0- Return file attributes in cx
                 1- Set file attributes to those in cx
                cx- Attribute to be set if AL=01
                 ds:dx- address of pathname
Exit parameters:        
                If carry set, 
                 ax contains one of the following error codes:
                  1- Invalid function
                  3- Pathname not found
                  5- Access denied
                If the carry is clear and the subfunction was zero,
                 cx will contain the file's attributes.</FONT></PRE>
<P><FONT face=Arial size=2>This call is useful for setting/resetting and reading 
a file's attribute bits. It can be used to set a file to read-only, set/clear 
the archive bit, or otherwise mess around with the file attributes.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-304></A>13.3.8.13 Get/Set 
File Date and Time</FONT></STRONG></P><PRE><FONT face="Courier New" size=2>Function (ah):  57h
Entry parameters:       
                al- Subfunction code
                 0- Get date and time
                 1- Set date and time
                bx- File handle
                cx- Time to be set (if AL=01)
                dx- Date to be set (if AL=01)
Exit parameters:        
                If carry set, ax contains one of the following error codes
                 1- Invalid subfunction
                 6- Invalid handle
                If the carry is clear, 
                 cx/dx is set to the time/date if al=00</FONT></PRE>
<P><FONT face=Arial size=2>This call sets the "last-write" date/time for the 
specified file. The file must be open (using open or create) before using this 
function. The date will not be recorded until the file is closed.</FONT></P>
<P><STRONG><FONT face=Arial size=3><A name=HEADING6-321></A>13.3.8.14 Other DOS 
Calls</FONT></STRONG></P>
<P><FONT face=Arial size=2>The following tables briefly list many of the other 
DOS calls. For more information on the use of these DOS functions consult the 
Microsoft MS-DOS Programmer's Reference or the MS-DOS Technical Reference. 
</FONT></P>
<DIV align=center>
<CENTER>
<TABLE borderColor=#c0c0c0 cellSpacing=0 cellPadding=0 width="100%" border=1>
  <CAPTION><FONT face=Arial size=2><STRONG>Miscellaneous DOS File 
  Functions</STRONG></FONT></CAPTION>
  <TBODY>
  <TR>
    <TH align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial size=2>Function 
      #(AH)</FONT></STRONG></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2>Input<BR>Parameters</FONT></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2>Output<BR>Parameters</FONT></TH>
    <TH align=middle bgColor=#f0f0f0><FONT face=Arial 
    size=2>Description</FONT></TH></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>39h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>ds:dx</CODE>- pointer to zero terminated 
      pathname.</FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2>Create Directory: Creates a new directory with 
      the specified name.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>3Ah</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>ds:dx</CODE>- pointer to zero terminated 
      pathname.</FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2>Remove Directory: Deletes the directory with 
      the specified pathname. Error if directory is not empty or the specified 
      directory is the current directory.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>3Bh</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>ds:dx</CODE>- pointer to zero terminated 
      pathname.<BR><BR>&nbsp;</FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2>Change Directory: Changes the default 
      directory to the specified pathname.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>45h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>bx</CODE>- file handle</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>ax</CODE>- new handle</FONT></TD>
    <TD><FONT face=Arial size=2>Duplicate File Handle: creates a copy of a 
      file handle so a program can access a file using two separate file 
      variables. This allows the program to close the file with one handle and 
      continue accessing it with the other.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>46h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>bx</CODE>- file 
      handle<BR><BR><CODE>cx</CODE>- duplicate handle</FONT></TD>
    <TD align=middle>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Force Duplicate File Handle: Like function 45h 
      above, except you specify which handle (in cx) you want to refer to the 
      existing file (specified by bx).</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>47h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>ds:si</CODE>- pointer to 
      buffer<BR><BR><CODE>dl</CODE>- drive</FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2>Get Current Directory: Stores a string 
      containing the current pathname (terminated with a zero) starting at 
      location ds:si. These registers must point at a buffer containing at least 
      64 bytes. The dl register specifies the drive number (0=default, 1=A, 2=B, 
      3=C, etc.).</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>5Ah</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>cx</CODE>- 
      attributes<BR><BR><CODE>ds:dx-</CODE> pointer to temporary path.</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>ax</CODE>- handle</FONT></TD>
    <TD><FONT face=Arial size=2>Create Temporary File: Creates a file with a 
      unique name in the directory specified by the zero terminated string at 
      which ds:dx points. There must be at least 13 zero bytes beyond the end of 
      the pathname because this function will store the generated filename at 
      the end of the pathname. The attributes are the same as for the Create 
      call.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>5Bh</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>cx</CODE>- 
      attributes<BR><BR><CODE>ds:dx</CODE>- pointer to zero terminated 
      pathname.</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>ax</CODE>- handle</FONT></TD>
    <TD><FONT face=Arial size=2>Create New File: Like the create call, but 
      this call insists that the file not exist. It returns an error if the file 
      exists (rather than deleting the old file).</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>67h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>bx</CODE>- handles</FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2>Set Maximum Handle Count: This function sets 
      the maximum number of handles a program can use at any one given 
      time.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><STRONG><FONT face=Arial 
      size=2>68h</FONT></STRONG></TD>
    <TD><FONT face=Arial size=2><CODE>bx</CODE>- handle</FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2>Commit File: Flushes all data to a file 
      without closing it, ensuring that the file's data is current and 
      consistent.</FONT></TD></TR></TBODY></TABLE></CENTER></DIV>
<P>&nbsp;</P>
<DIV align=center>
<CENTER>
<TABLE borderColor=#c0c0c0 cellSpacing=0 cellPadding=0 width="100%" border=1>
  <CAPTION><FONT face=Arial size=2><STRONG>Miscellaneous DOS 
  Functions</STRONG></FONT></CAPTION>
  <TBODY>
  <TR>
    <TH vAlign=center align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>Function<BR>#(AH)</STRONG></FONT></TH>
    <TH vAlign=center align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2>Input Parameters</FONT></TH>
    <TH vAlign=center align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2>Output Parameters</FONT></TH>
    <TH vAlign=center align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2>Description</FONT></TH></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>25h</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- interrupt # 
      <CODE>ds:dx</CODE>- pointer to interrupt service routine.</FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Set Interrupt Vector: Stores the specified 
      address in ds:dx into the interrupt vector table at the entry specified by 
      the al register.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>30h</STRONG></FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- major version 
      <CODE>ah</CODE>- minor version <CODE>bh</CODE>- Version flag 
      <CODE>bl</CODE>:cx- 24 bit serial number</FONT></TD>
    <TD><FONT face=Arial size=2>Get Version Number: Returns the current 
      version number of DOS (or value set by SETVER).</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>33h</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- 0</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>dl</CODE>- break flag (0=off, 
      1=on)</FONT></TD>
    <TD><FONT face=Arial size=2>Get Break Flag: Returns the status of the DOS 
      break flag. If on, MS-DOS checks for ctrl-C when processing any DOS 
      command; if off, MS-DOS only checks on functions 1-0Ch.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>33h</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- 1 <CODE>dl</CODE>- break 
      flag.</FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Set Break Flag: Sets the MS-DOS break flag 
      according to the value in dl (see function above for 
details).</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>33h</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- 6</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>bl</CODE>- major version 
      <CODE>bh</CODE>- minor version <CODE>dl</CODE>- revision <CODE>dh</CODE>- 
      version flags</FONT></TD>
    <TD><FONT face=Arial size=2>Get MS-DOS Version: Returns the "real" version 
      number, not the one set by the SETVER command. Bits three and four of the 
      version flags are one if DOS is in ROM or DOS is in high memory, 
      respectively.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>34h</STRONG></FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2><CODE>es:bx</CODE>- pointer to InDOS 
      flag.</FONT></TD>
    <TD><FONT face=Arial size=2>Get InDOS Flag Address: Returns the address of 
      the InDOS flag. This flag helps prevent reentrancy in TSR applications 
      </FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>35h</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- interrupt #</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>es:bx</CODE>- pointer to interrupt 
      service routine.</FONT></TD>
    <TD><FONT face=Arial size=2>Get Interrupt Vector: Returns a pointer to the 
      interrupt service routine for the specified interrupt number. See function 
      25h above for more details.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>44h</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- subcode Other 
      parameters!</FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Device Control: This is a whole family of 
      additional DOS commands to control various devices. See the DOS 
      programmer's reference manual for more details.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>4Dh</STRONG></FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- return value <CODE>ah</CODE>- 
      termination method</FONT></TD>
    <TD><FONT face=Arial size=2>Get Child Program Return Value: Returns the 
      last result code from a child program in al. The ah register contains the 
      termination method, which is one of the following values: 0-normal, 
      1-ctrl-C, 2-critical device error, 3-terminate and stay 
  resident.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>50h</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>bx</CODE>- PSP address</FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Set PSP Address: Set DOS' current PSP address 
      to the value specified in the bx register.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>51h</STRONG></FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>bx</CODE>- PSP address</FONT></TD>
    <TD><FONT face=Arial size=2>Get PSP Address: Returns a pointer to the 
      current PSP in the bx register.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>59h</STRONG></FONT></TD>
    <TD align=middle><FONT face=Arial size=2>-</FONT></TD>
    <TD><FONT face=Arial size=2><CODE>ax</CODE>- extended error 
      <CODE>bh</CODE>- error class <CODE>bl</CODE>- error action 
      <CODE>ch</CODE>- error location</FONT></TD>
    <TD><FONT face=Arial size=2>Get Extended Error: Returns additional 
      information when an error occurs on a DOS call. See the DOS programmer's 
      guide for more details on these errors and how to handle 
them.</FONT></TD></TR>
  <TR>
    <TD align=middle bgColor=#f0f0f0><FONT face=Arial 
      size=2><STRONG>5Dh</STRONG></FONT></TD>
    <TD><FONT face=Arial size=2><CODE>al</CODE>- 0Ah ds:si- pointer to 
      extended error structure.</FONT></TD>
    <TD>
      <P align=center><FONT face=Arial size=2>-</FONT></P></TD>
    <TD><FONT face=Arial size=2>Set Extended Error: copies the data from the 
      extended error structure to DOS' internal 
record.</FONT></TD></TR></TBODY></TABLE></CENTER></DIV>
<P><FONT face=Arial size=2>In addition to the above commands, there are several 
additional DOS calls that deal with networks and international character sets. 
See the MS-DOS reference for more details.</FONT></P>
<DIV align=center>
<CENTER>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD vAlign=center noWrap align=middle width="100%" bgColor=#000000 colSpan=3 
    height=1></TD></TR>
  <TR>
    <TD vAlign=center noWrap align=middle width="34%" bgColor=#ffffff>
      <P align=left><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 6)-Dateien/WB00823_.gif" 
      width=12 align=absMiddle border=0></A><FONT face=Arial size=2><STRONG> <A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-5.html">Chapter 
      Thirteen</A> (Part 5)</STRONG></FONT></P></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/toc.html"><FONT 
      face=Arial size=2><STRONG>Table of Content</STRONG></FONT></A></TD>
    <TD vAlign=center noWrap align=middle width="33%" bgColor=#ffffff>
      <P align=right><FONT face=Arial size=2><STRONG><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-7.html">Chapter 
      Thirteen</A> (Part 7)&nbsp; </STRONG></FONT><A 
      href="http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_13/CH13-7.html"><IMG 
      height=24 
      src="CHAPTER THIRTEEN MS-DOS, PC-BIOS AND FILE I-O (Part 6)-Dateien/WB00827_.gif" 
      width=12 align=absMiddle 
border=0></A></P></TD></TR></TBODY></TABLE></CENTER></DIV>
<P align=right><FONT face=Arial size=2><STRONG>Chapter Thirteen: MS-DOS, PC-BIOS 
and File I/O (Part 6)<BR>28 SEP 1996</STRONG></FONT></P></BODY></HTML>
